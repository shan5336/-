# JS高级

## 面向对象

### 一、面向对象编程介绍

####     1.1 两大编程思想

```
    面向过程和面向对象
```

####     1.2 面向过程：

```
POP 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步的实现，使用的时候
        再一次一个个调用就可以了
```

####     1.3 面向对象：

```
OOP 是把事物分解成一个一个对象，然后由对象之间分工与合作。面向对象是以对象功能来划
        分问题，而不是步骤。例如，将大象装进冰箱，先找出对象，并写出这些对象的功能,然后使用这些功能。
        1.面向对象的特征：
          封装性：封装起来直接使用
          继承性：子继承父的功能
          多态性：不同情况有不同功能
```

### 二、ES6中的类和对象

####     2.1 面向对象的思维特点

```
   抽取(抽象)对象共用的属性和行为组织(封装)成一个类(模板)
      对类进行实例化，获取类的对象
```

####     2.2 对象

```
  现实生活中，万物皆对象，对象是一个具体的事物，看得见摸得着的东西。
      JS中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象。
```

####     2.3 类 class

```
    在ES6中新增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。
      类抽象了对象的公共部分，它泛指某一大类。苹果，手机，人。。。
      对象特指某一个，通过实例化一个具体的对象。这个苹果，这台手机，丘汝航 
```

##### 1.创建类

```
class name{
//class body
        }
```

#####         创建实例：

```
var x=new name();
```

##### 2.类constructor构造函数

```
constructor()方法是类的构造函数(默认方法),用于传递参数，返回实例对象，通过new命令生成对象实例时，自己调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor()
```

##### 3.类中添加方法  (1)类里面的函数不需要加function

```
结构：
        class Person{
constructor(name,age){
    this.name=name;
    this.age=age;
}  (2)多个函数方法之间不需要添加逗号分隔开
say(){
    console.log(this.name+'你好')；
}
        }
        调用方法：
        实例.say();
```

### 三、类的继承

####     3.1 继承

```
  程序中的继承：子类可以继承父类的一些属性和方法
```

####     3.2 语法

```
    class Father{  父类
      }
      class Son extends Father{  子类继承父类
      } 
```

####     3.3 super关键字

```
 super关键字用于访问和调用对象父亲上的函数，可以调用父亲的构造函数，也可以调用父亲的普通函数
      调用父亲的构造函数：super(参数);
      调用父亲的普通函数：super.函数名();
      子类在构造函数中使用super,必须放到this前面(必须先调用父类的构造方法再使用子类的构造方法)
```

####     3.4 继承中属性或方法的查找原则：就近原则

```
   继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类
      继承中，如果子类里面，没有，就去查找父亲有没有这个方法，如果有就去执行父类的这个方法
```

####     3.5 ES6中的类和对象的三个注意点

```
 1.在ES6中没有变量提升，所以必须先定义类，才能通过类实例化对象
 2.类里面的共有属性和方法一定要加this使用 this.name或者this.sing();
 3.类里面的this指向问题
   constructor里面的this指向的是由Star创建出来的实例
   方法里面的this指向它的调用者
```

### 四、面向对象案例

####     4.1新用到的知识点 

#####       1.把创建的元素追加到对应的元素中  element.insertAdjacentHTML("position",text);       

```
 以前做法：动态创建元素creatElement,但是元素里面的内容较多，需要innerHTML赋值,再追加到父元素
        现在的做法：利用insertAdjacentHTML()可以直接把字符串格式元素添加到父元素中
        用法:insertAdjacentHTML()
        element.insertAdjacentHTML("position",text); 
        position:

 1.beforebegin 元素自身的前面

      2.afterbegin 插入元素内部的第一个子节点之前
      3.beforeend 插入元素内部的最后哦一个子节点之后
      4.afterend 元素自身的后面

    appendChild不支持追加字符串的子元素，insertAdjacentHTML支持追加字符串的元素
```

#####       2.双击事件：ondblclick

#####       3.禁止选中文字:

```
 window.getSelection?window.getSelection().removeAllRanges():document.selection.empty();
```

#####       4.删除指定的元素        

```
element.remove();   例:that.lis[index].remove();
```

#####       5.选中文字

```
  element.select();  例:input.select();
```

## 构造函数和原型

### 一、构造函数和原型

####   1.1 概述

#####     1.ES6

```
全称ECMAScript6.0，在ES6之前，对象不是基于类创建的，而是用一种称为构造函数的特殊函数来定义对象和他们的特征
```

#####     2.创建对象的三种方式

```
  利用字面量创建对象：var obj={}
    用new Object创建对象,调用系统的构造函数创建对象：var 变量名=new Object();
    利用构造函数创建对象：function 构造函数名(){}    new 构造函数名(); 
```

######     new干了什么事

```
 1.在内存中开辟空间（申请一块空闲的空间），存储创建的新的对象  创建一个新的空对象
        2.把this设置为当前的对象  this指向刚才创建的空对象
        3.设置对象的属性和方法的值
        4.把this这个对象返回,所以不需要return
```

####   1.2  构造函数：

```
1.JS的构造函数中可以添加一些成员(属性和方法)，可以在构造函数本身身上添加，也可以在构造函数内部
      this上添加，通过这种方式添加成员，就分别称为静态成员和实例成员
      实例成员：在构造函数内部通过this创建的对象成员称为实例成员，只能由实例化的对象来访问  ldh.name
      静态成员：在构造函数上添加的成员称为静态成员，只能由构造函数本身来访问  Star.sex
```

####   1.3 构造函数的问题    

```
1.每次创建对象都需要开辟新的空间，并且里面的方法又会占用别的空间，比较浪费内存，浪费时间
      里面的一些方法的函数代码是一样的，我们希望所有的对象使用同一个函数，这样比较节省内存
```

####   1.4 构造函数原型 prototype(原型对象)  解决构造函数浪费空间的问题

```
   1.构造函数通过原型分配的函数是所有对象共享的
    2.JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是
      一个对象，这个对象所有的属性和方法，都会被构造函数所拥有。
    3.我们可以把那些不变的方法，直接定义在prototype对象上，这样所有的对象的实例就可以共享这些方法。
```

####   1.5 对象原型 __proto__

```
1.对象都会有一个属性__proto__指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数
      prototype原型对象的属性和方法，就是因为对象有__proto__原型的存在
    2.方法的查找规则：首先先看对象身上是否有指定的方法，如果有就执行，
      如果没有这个方法，因为有__proto__的存在，就去构造函数原型对象prototype身上去查找这个方法
    3.__proto__对象原型和原型对象是等价的  也就是Star.prototype=ldh.__proto__
    4.__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但它是一个非标准属性，因此实际开发中，不可以使用这个属性,比如不能进行赋值，他只是内部指向原型对象prototype
```

####   1.6 constructor构造函数

```
1.对象原型(__proto__)和构造函数原型对象(prototype)里面都有一个属性constructor属性，constructor
      我们称为构造函数，因为它指回构造函数本身。
    2.constructor主要用于记录该对象引用于那个构造函数，它可以让原型对象重新指向原来的构造函数
    3.很多情况下，我们需要手动的利用constructor这个属性指回原来的构造函数
```

####   1.7构造函数，实例，原型对象三者之间的关系   

```
 1.构造函数有一个属性prototype指向原型对象prototype;  
      Star.prototype——>Star原型对象prototype
    2.原型对象prototype有一个属性constructor指向构造函数;  
      Star.prototype.constructor=Star(构造函数)
    3.构造函数可以生成一个实例对象
      实例对象有一个__proto__指向Star原型对象prototype；
      ldh.__proto__=Star.prototype
      实例对象的__proto__的constructor指向构造函数；
      ldh.__proto__.constructor=Star
```

####   1.8原型链

```
 1.只要是对象就有__proto__原型，指向原型对象prototype 
    2.Star原型对象(Star.prototype)里面的__proto__原型指向的是Object.prototype
    3.我们Object.prototype原型对象里面的__proto__原型指向为null
```

####   1.9JavaScript的成员查找机制(规则)

```
   1.当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性
    2.如果没有就查找它的原型(也就是__proto__指向的prototype原型对象)
    3.如果还没有找到就查找原型对象的原型(Object的原型对象)
    4.依此类推一直找到Object为止(null)
    5.__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条线路
```

####   1.10 原型对象this指向问题

```
1.构造函数中，里面的this指向的是对象实例，指向通过构造函数创建的对象实例
2.原型对象函数里面的this指向的是实例对象，也就是谁调用了这个函数，那就指向谁，没调用不能确定指向谁
```

####   1.11 扩展内置对象(给原来的内置对象添加新的方法)

```
 1.可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能
 2.数组和字符串内置对象不能给原型对象覆盖操作Array.prototype={},
   只能是Array.prototype.xxx=function(){}的方式 
```

### 二、继承

####   2.1 组合继承

```
ES6之前并没有给我们提供extends继承，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承
```

####   2.2 call()函数 

```
 1.调用fun这个函数，并且修改函数运行时的this指向
 2.语法格式：
     fun.call(thisArg,arg1,arg2,...)
     thisArg:当前调用的函数this的指向对象
     arg1,arg2....:传递的其他参数
```

####   2.3 借用构造函数继承父类型属性

```
 1.核心原理：通过call把父类型的this指向子类型的this,这样就可以实现子类型继承父类型的属性
      Father.call(this,其他参数...) 
      让父类型的this指向子类型的this,这个this也就是当前子类型的指向对象
```

####   2.4 借用原型对象继承父类型方法

```
 1.步骤
     a.实例化一个Father对象，并让它赋给Son的原型对象  Son.prototype=new Father();
     b.此时Son.prototype可以通过Son.prototype.__proto__访问Father.prototype,也就是可以使用
       Father.prototype上面的属性和方法
     c.可以在Son.prototype上添加自己的方法，不会影响到Father.prototype
     d.这种方法是用Father的实例对象覆盖原来的Son.prototype，现在的constructor指向的是Father这个构造
       函数，但是Son.prototype.constructor应该是指向Son这个构造函数的,因此我们需要手动改变它的指向，让它指回Son。 Son.prototype.constructor=Son;
```

### 三、ES5中的新增方法

####   3.1 数组方法

```
迭代(遍历)方法：forEach()、map()、filter()、some()、every();
```

#####    1.1 forEach()

```
    语法：array.forEach(function(currentValue,index,arr))
    currentValue:数组当前项的值
    index:数组当前项的索引
    arr:数组对象本身
    forEach()里面return是不会终止迭代的
```

#####    1.2 filter()：

```
创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组
语法：array.filter(function(currentValue,index,arr))
它直接返回一个新数组
```

#####    1.3 some()：

```
用于检测数组中的元素是否满足指定条件，查找数组中是否有满足条件的元素
返回值是布尔值，如果查找到这个元素，就返回true,如果查找不到就返回false
如果找到第一个满足条件的元素，则终止循环，不再继续查找
语法：array.filter(function(currentValue,index,arr))
```

####   3.2 字符串方法

#####    1.1 trim() 

```
从一个字符串的两端删除字符
    语法：str.trim() 
    不影响原来的字符，返回的是一个新的字符串
    一般用于表单提交的时候去除用户输入的一些多余的空格
```

####   3.3 对象方法

#####    1.1  Object.keys() 用于获取对象自身所有的属性

```
  语法：Object.keys(obj)
    效果类似于for...in
    返回一个由属性名组成的数组
```

#####    1.2  Object.defineProperty() 定义新属性或修改原有的属性

```
语法：Object.defineProperty(obj,prop,descriptor)
    obj：必须有的，目标对象
    prop：必须有的，需定义或者修改的属性的名字,是一个字符串
    descriptor：必须有的，目标属性所拥有的特性
        descriptor说明：以对象形式{}书写
        value:设置属性的值，默认undefined
        writable：值是否可以重写，true|false 默认是false不可重写
        enumerable:目标属性是否可以被枚举，true|false 默认是false不能被遍历出来
        configurable:目标属性是否可以被删除或者是否可以被再次修改特性，true|false 默认是false不能被修改
```

## 函数进阶

### 一、函数的定义和调用

####    1 函数的定义方式

#####     1.1 函数声明方式function关键字(命名函数)

```
      function fn(){}
```

#####     1.2 函数表达式(匿名函数)   

```
 var fun=function(){}
```

#####     1.3 利用new Function("参数1","参数2","函数体")   

```
     Function里面的参数都是字符串格式
        执行效率低，不方便使用，使用较少
        所有函数都是Function的实例(对象),函数也是对象
        eg:
        var f=new Function("a","b","console.log(a+b)");//定义一个函数
        f(1,2);//调用
```

#### 2.函数的调用方式

```
1.普通函数  fn() 或者 fn.call()
    2.对象的方法   obj.say()  
    3.构造函数   new Star()
    4.绑定事件函数  btn.onclick=function(){}
    5.定时器函数   setInterval(function(){},1000)或者setTimeout(function(){},1000)
    6.立即执行函数   (function(){函数体})();或者(function(){}())
```

### 二、this

####    1. 函数内this的指向

#####     1.1 这些this的指向，是当我们调用函数的时候确定的，调用的方式的不同决定了this的指向不同，一般指向我们的调用者。

#####     1.2 常见调用方式和this指向

```
普通函数调用：window
        对象方法调用：该方法所属对象
        构造函数调用：实例对象，原型对象里面的方法也指向实例对象、
        事件绑定方法：绑定事件对象
        定时器函数：window
        立即执行函数：window 
```

### 三、严格模式

####    3.1 什么是严格模式  ie10以上

######     1.JS除了提供正常模式之外，还提供了严格模式。ES5的严格模式是采用具有限制性JavaScript变体的一种方式， 即在严格的条件下运行JS代码

######     2.严格模式对正常的JavaScript语义做了一些更改：

​      1.消除了JavaScript语法的一些不合理，不严谨之处，减少了一些怪异行为
​      2.消除了代码运行的一些不安全之处，保证代码运行的安全
​      3.提高了编译器效率，增加运行速度
​      4.禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的javascript做好铺垫。
​        比如一些保留字：class,enum,export,extends,import,super不能做变量名。

####    3.2 开启严格模式

严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为脚本开启严格模式和为函数开启严格模式两种情况。

######     1.为脚本(script标签)开启严格模式

        <script>
            "use strict";//下面的js代码就会按照严格模式执行代码，单引双引都行
        </script>

为了防止变量污染我们也可以代码放到一个立即执行函数里面，也可以执行严格模式
        <script>
            (function(){
                "use strict";
            })();
        </script>

######  2.为某个函数开启严格模式

       <script>
            function fn(){
               "use strict";////下面的js代码就会按照严格模式执行代码
            }
       </script>

#### 3.3 严格模式中的变化

####  1.变量规定：

   

```
1.正常模式中，如果一个变量没有声明就赋值，默认是隐式全局变量。严格模式禁止这种用法，变量都必须先用var声明，然后再使用。
   2.严禁删除已经声明变量，比如如果使用delete x;语法是错误的
```



####  2.严格模式下this指向问题

   

```
1.以前在全局作用域函数中的this指向window对象。严格模式下全局作用域中函数的this是undefined
   2.以前构造函数时不加new也可以调用，当普通函数，this指向的是全局对象window。严格模式下，如果构造函数不加new调用，this指向的是undefined，无法进行赋值操作会报错，如果是new了，那this 还是指向对象实例
   3.定时器下的this还是指向window
   4.事件，对象还是指向调用者
```



####  3.函数变化

   

```
1.函数不能有重名的参数
   2.函数必须声明在顶层，新版本JS会引入块级作用域(ES6),为了于新版本接轨，不允许在非函数的代码块内声明函数。也就是不要再if、for的块内声明函数
```



### 四、高阶函数

   

```
高阶函数是对其他函数进行操作的函数，它接收函数作为参数或者将函数作为返回值输出 
```



####    1.函数可以作为参数传递

   

```
function fn(a,b,callback){
        console.log(a+b);
        callback&&callback();
    }
    fn(1,2,function(){
        console.log("我是最后调用的")
    });
```



####    2.函数可以作为返回值输出

### 五、闭包

####    5.1 作用域

 

```
   根据作用域的不同分为两种：全局变量和局部变量
    1.函数内部可以使用全局变量
    2.函数外部不可以使用局部变量
    3.当函数执行完毕，本作用域内的局部变量会销毁 
```



####    5.2 闭包(是一个函数)

####     1.定义

```
闭包(closure)指有权访问另一个函数作用域中变量的函数。通俗点就是，一个作用域可以访问另一个函数内部的局部变量，被访问的那个函数就是一个闭包函数
```



####     2.fn外面的作用域可以访问fn内部的局部变量做法实现：

将函数作为一个返回值返回，在外面调用函数，并且用一个变量来接收它，此时这个变量是一个函数，再对用来接收它的这个函数进行调用就可以实现了
    

```
function fn(){
        var num=10;
        return function(){//直接返回一个匿名函数
            console.log(num);
        }
    }
    var f=fn();//调用fn这个函数，会把fun作为返回值返回，此时用f进行接收，此时f是一个函数
    f();
```



####     3.闭包的主要作用：

```
延伸了变量的作用范围
```



####     4.闭包案例:

######       点击li输出当前li的索引号

######       三秒钟之后打印所有li元素的内容

######       计算打车价格

####     5.闭包两道思考题：

```
this的指向问题
```



### 六、递归

####    6.1 什么是递归？

​    

```
如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 
    简单理解：函数内部自己调用自己，这个函数就是递归函数
    递归函数的作用和循环效果一样
    由于递归很容易发生“栈溢出”错误(stack overflow),所以必须要加退出条件return
```



####    6.2 利用递归求数学题

​    

```
1.累加器/累乘器
    2.斐波那契数列
```



####    6.3 利用递归遍历数组

####    6.4 浅拷贝和深拷贝

 

```
   1.浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用
    2.深拷贝拷贝多层，每一级别的数据都会拷贝 
    3.Object.assign(target,..source)  es6新增方法可以实现浅拷贝
```



## 正则表达式

### 一、正则表达式概述

####   1.1 什么是正则表达式？

​    正则表达式(Regular Expression)：适用于匹配字符串中字符组合的模式，在JavaScript中，正则表达式也是对象。
​    正则表达式通常用来检索、替换那些符合某个模式(规则)的文本，比如验证表单：用户名表单只能输入英文字母，数字或者下划线，昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等。

####   1.2 正则表达式的特点

​    

```
1.灵活性、逻辑性和功能性非常强
    2.可以迅速的用极简单的方式达到字符串的复杂控制
    3.对于刚接触的人来说，比较晦涩难懂
    4.实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式
```



### 二、正则表达式在JavaScript中的使用

####   2.1 创建正则表达式

##### 在JavaScript中，可以通过两种方式创建一个正则表达式

#####     1.通过调用RegExp对象的构造函数创建 

​    

```
var regexp=new RegExp(/表达式/);
```



#####     2.通过字面量创建

 

```
   var regexp=/表达式/;
```



####   2.2测试正则表达式test

​    

```
test()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false,参数是测试字符串
    tegexObj.test(str)
    tegexObj:正则表达式
    str：测试的文本
    就是检测str文本是否符合我们写的正则表达式规范
```



### 三、正则表达式中的特殊字符

####   3.1 正则表达式的组成

​    一个正则表达式可以由简单的字符串构成，比如/abc/,也可以是简单和特殊字符字符组合，比如/ab*c/。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用字符，^、$、+等等

#####     参考工具：

  

```
  MDN：https://developer.mozilla.org/zh-CN/
    jQuery手册：正则表达式部分
    正则测试工具：http://tool.oschina.net.regex 
```



####   3.2 边界符：用来提示字符所处的位置

   

```
 ^:表示匹配首行的文本(以谁开始)
    $:表示匹配行尾的文本(以谁结束)
    /^字符串$/：精确匹配
```



####   3.3 字符类:[] 表示有一系列字符可供选择，只要匹配其中一个就可以了

   

```
1./[字符串]/:出现了字符串中的任意一个就返回true
    /^[字符串]$/:只能出现字符串中的其中一个，其他都为false
2.[-]:方括号内部范围符-
    /^[a-z]$/:输入小写a-z中的其中一个就会返回true
3.字符组合
    /^[a-zA-Z]$/;  26个英文字母大写或者小写其中一个
4.内部取反符[^]
    /^[^a-zA-Z]$/; 不允许26个英文字母大写或者小写其中一个
```

####   3.4 量词符：设定某个模式出现的次数 

```
 *：重复零次或者更多次
    +:重复一次或者更多次
    ?:重复零次或者一次
    {n}:重复n次
    {n,}:重复n次或者更多次
    {n,m}:重复n-m次
```

####   3.5 预定义类：指某些常见模式的简写

```
 \d：匹配0-9之间的任一数字，相当于[0-9]
\D：匹配除了0-9之间的任一数字，相当于[^0-9]
 \w：匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]
\W：匹配任意的除了字母、数字和下划以外的字符，相当于[^A-Za-z0-9_]
 \s：匹配空格(包括换行符、制表符、空格等)，相当于[\t\r\n\v\f]
 \S：匹配非空格字符，相当于
```

####   3.6 在线测试工具/常用正则表达式

```
 https://c.runoob.com/   
```

### 四、正则表达式中的替换

####   4.1 replace替换

```
 replace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或者是一个正则表达式
    stringObject.replace(regexp/substr,replacement); 
    1.第一个参数：被替换的字符串或者正则表达式
    2.第二个参数：替换为字符串
    3.返回值是一个替换完毕的新字符串
```

####   4.2正则表达式参数    

```
/表达式/[switch]
switch(也称为修饰文本)按照什么样的模式来匹配，有三种值：
g:全局匹配
i:忽略大小写
gi:全局匹配+忽略大小写
```

------

## ES6

### 一、ES6概述

### 二、ES6新增语法

####     1. let变量

​      ES6中新增的用于声明变量的关键字

```
特点

1.let声明的变量只在所处的块级有效
   ES6增加了添加了块级作用域 块级作用域就是一对大括号
2.使用let关键字声明的变量才具有块级作用域的特性，使用var声明的变量不具有块级作用域的的特性防止循环变量变成全局变量
3.使用let声明的变量不存在变量提升，只能先声明，再使用
4.使用let声明的变量具有暂时性死区
  在块级作用域下用let声明的变量会被暂时的绑定在这个区域，不受外部代码的影响
5.let面试题
  //第一题
  var arr=[];
  for (var i = 0; i < 2; i++) {
      arr[i]=function(){
         console.log(i);
      }
  }
  arr[0]();//i=2
  arr[i]();//i=2 
  //第二题
  var arr=[];
  for (let i = 0; i < 2; i++) {
   	 arr[i]=function(){
        console.log(i);
     }
  }
   arr[0]();//0
   arr[1]();//1
   //每一次循环都会产生一个块级作用域，每一次循环产生的i都是不同的，也就是说，第一次循环的时候，产生一个let i=0时的作用域，第二产生的i跟第一个i时是不同的
```

#### 2. const

```
作用:声明常量，常量就是值(内存地址)不能变化的量 
  1.具有块级作用域，不具有变量提升
  2.声明常量时必须赋值
  3.常量赋值后，值或者是存储地址不能修改
```

#### 3. 解构赋值

  ES6中允许从数组中提取值，按照对应的位置，对变量进行赋值，对象也可以实现解构

#####   1.数组解构  

```
let arr=[1,2,3];
    let [a,b,c]=arr;//与数组中的一一对应
    let [a,b]=arr;//一一对应
    let [a,b,c,d]=arr;//d会undefined
```

#####   2.对象解构

​    1.方法1

```
let person={
    name:"丘汝航",
    age:21
}
let {age,name,sex}=person;//使用变量匹配属性的名字
console.log(age);
console.log(name);
console.log(sex);//undefined 
```

​    2.方法2 

```
  let person={
        name:"丘汝航",
        age:21
      }
      let {name:myname,age:myage}=person;
      //name与person里面的属性进行匹配，匹配成功赋值给myname
      //myname和myage才是真正的变量，name和age只是用于匹配person
```

#### 4. 箭头函数:

  ES6中新增的定义函数的方式,用来简化函数定义

```
1.语法：(形参)=>{函数体}
        const fn=()=>{} 
  2.箭头函数的特点：
    a.函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号
    b.如果形参只有一个，形参外面的小括号可以省略
  3.箭头函数this问题
    1.箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this
    	const obj={
            name:"张三"
        }
        function fn(){
            console.log(this);
            return ()=>{
                console.log(this)
                //箭头函数的this指向的是箭头函数定义区域的this,也就是现在指向的是fn这个函数区域的this
            }
        }
        const resFn=fn.call(obj);//fn内部的this指向了obj
        resFn();//指向obj
        
        箭头函数面试题
        var age=100;
        var obj={//对象不能产生作用域
            age:20,
            say:()=>{
                alert(this.age)
            }
        }
        obj.say();//100
        //this被定义在了obj里面,obj是一个对象，对象不会产生作用域，因此箭头函数实际上被定义在了全局作用下，也就是这里的this指向的是window
        
```

#### 5.剩余参数：

  剩余参数允许我们将一个不定数量的参数表示为一个数组
  当函数实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中 

```
1.语法：(...args)
    function fn(...args) 表示接收所有的参数这个args是自己命名的，但是前面一定要有...
  2.剩余参数和解构配合使用
    let arr=["张三","李四","王五"];
    let [s1,...s2]=arr;
    s1对应张三，其他剩下的给s2
```

#### 6.ES6内置对象的扩展

##### 1.Array的扩展方法

######   1.1 扩展运算符(展开语法) 

```
a.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列
b.扩展运算符可以应用于合并数组
  let arr3=[...arr1,...arr2];
  arr1.push[arr2];
c.可以将伪数组转换为真正的数组
  方法一：
  var divs=document.querySelectorAll("div");
  var arr4=[...divs];
  方法二：构造函数方法 Array.from()
  Array.from(参数1,参数2)
  参数1接收一个伪数组作为参数
  参数2可以传入一个函数，类似于map方法，用来对每个元素进行处理，将处理后的值放入返回的数组
  返回值是将伪数组转换后的真正的数组
```

######     1.2 实例方法：find()

```
 用于找出第一个符合条件的数组成员，如果没有找到就返回undefined
  接收一个函数作为参数，在函数当中有两个形参，分别为item和index(分别代表当前循环的值，对应的索引)
```

######     1.3 实例方法： findIndex()

```
找出第一个符合条件的数组成员的位置，如果没有找到返回-1
```

######     1.4 实例方法:includes()

```
用于查找某个数组是否包含给定的值，参数是给定的那个值，返回的是一个布尔值
```

##### 2.String的扩展方法

######  1.模板字符串

ES6中新增的创建字符串的方法，使用反引号定义

######     语法：

```
  let name=`张三`;
```

######     1.2 模板字符串的特点：

```
a.模板字符串中可以解析变量 ${ }
  let name=`张三`;
  let sayHello=`你好，我的名字叫${name}`;
b.模板字符串中可以换行
c.在模板字符串中可以调用函数
  语法格式：`${函数()}`
```

######     1.3 实例方法：startsWith()和endsWith()

```
startsWith():表示参数字符串是否在原字符串的头部，返回布尔值
endsWith():表示参数字符串是否在原字符串的尾部，返回布尔值
```

######     1.4 实例方法：repeat(n)

```
表示将原字符串重复n次，返回一个新字符串
```

#### 7.Set数据结构

  ES6提供了新的数据结构Set,类似于数组，但是成员的值都是唯一的，没有重复的值。
  用途：搜索历史记录

#####   1.创建Set数据结构    

```
a.Set本身是一个构造函数，用来生成Set数据结构 
    b.Set函数可以接收一个数组做为参数，用来初始化
      利用Set来进行数组去重
      let arr=new Set([数组]);
      let arr1=[...arr];
```

#####   2.Set的实例方法    

```
a.add(value).add(value).add(value):添加某个值，可以链式调用返回Set本身
    b.delete(value):删除某个值，返回一个布尔值，表示是否删除成功
    c.has(value):表示该值是否是Set的成员，返回一个布尔值
    d.clear():清除所有成员，没有返回值9
```

#####   3.遍历

​    Set结构的实例与数字一样，也拥有forEach方法,用于对每个成员执行某种操作，没有返回值

```
s.forEach(value=>console.log(value))
```

------