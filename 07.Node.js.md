# Node.js

## node.js开发基础

### 一、node开发概述

#### 	1.1 为什么要学习服务器端开发基础

#### 	1.2 服务器端开发要做的事情   

```
    实现网站的业务逻辑 
    数据的增删改查
```

#### 	1.3 为什么选择Node   

```
    使用JavaScript语法开发后端应用
    一些公司要求前端工程师掌握Node开发
    Node生态系统活跃，有大量开源库可以使用
    前端开发工具大多基于Node开发
```

#### 	1.4 Node是什么    

```
    Node是基于Chrome V8引擎的JavaScript代码运行环境
```

### 二、node运行环境搭建

```
    2.1 Node.js运行环境安装
    官网：https://nodejs.org/en/
    查看是否安装成功；
    powershell 输入node -v 回车
```

### 三、node.js快速入门

#### 	3.1 Node.js的组成

```
	Node.js是有ECMAScript及Node环境提供的一些附加API组成的，包括文件,网络,路径等等一些更强大的API
```

#### 	3.2 Node.js基础语法

```
	所有ECMAScript语法在Node环境中都可以使用
```

####  	3.3 Node.js全局对象global    

```
    在浏览器中全局对象是window,在Node中全局对象是global
    Node中全局对象下有以下方法，可以在任何地方使用，global可以省略。
    console.log()   在控制台中输出
    setTimeout()   设置超时定时器
    clearTimeout() 清除超时时定时器
    setInterval()   设置间歇定时器
    clearInterval()  清除间歇定时器
```

## Node.js模块化开发

### 一、系统模块

#### 	1.什么是系统模块

```
	Node运行环境提供的API，因为这些API都是以模块化的方式进行开发的，所以我们又称为Node运行环境提供的API为系统模块。
```

#### 	2.文件操作模块fs(file system)：读取文件，写入文件，创建文件夹

#####  		a.写入：

```
 	const fs=require('fs')
```

#####  		b.读取文件内容:

```
    fs.readFile('文件路径/文件名称'[,'文件编码'],callback);
    callback:回调函数，文件读取完成之后会调用，里面有两个参数，第一个参数是err,如果文件读取发生错误 参数err的值为错误对象，否则err的值为null
    
    示例代码：
    const fs=require('fs');
    fs.readFile('./08.系统模块.js','utf8',(err,doc)=>{
        //如果文件读取出错，err是一个对象，包含错误信息
        //问价读取正确，err为null
        /* console.log(err);
        console.log(doc); */
        if(err==null){
            console.log(doc);
        }
    })
```

#####  		c.写入文件内容；

```
	fs.writeFile('文件路径/文件名称','数据',callback); 如果没有这个文件就会自己创建一个
	
	示例代码：
	const fs=require('fs');
    const content='123456789';
    fs.writeFile('./demo.txt',content,err=>{
        if (err!=null) {
            console.log(err);
            return;
        }
        console.log('文件读取成功');
    })
```

#### 	3.系统模块path 路径操作

#####  		a.为什么要进行路径拼接？ 

```
    不同操作系统的路径分隔符不统一，Window上是/或\，linux上是/
    路径拼接语法：path.join('路径'，'路径'...)
```

##### 		b.相对路径与绝对路径 

```
    大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录
    在读取文件或者设置文件路径时都会选择绝对路径
    使用__dirname获取当前文件所在的绝对路径
```

### 二、第三方模块

#### 	1.什么是第三方模块

```
    别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。

    第三方模块有两种存在形式：
    以js文件的形式存在，提供实现项目具体功能的API接口。
    以命令行工具形式存在，辅助项目开发
```

#### 	2. 获取第三方模块

```
	npmjs.com：第三方模块的存储和分发仓库
```

```
    npm (node package manager) ： node的第三方模块管理工具
    下载：npm install 模块名称 在命令行中输入，默认下载到命令行当前文件夹下
    卸载：npm uninstall package 模块名称 在命令行中输入 
```

```
    全局安装与本地安装
    命令行工具：全局安装
    库文件：本地安装
```

#### 	3.第三方模块nodemon

```
    nodemon是一个命令行工具，用以辅助项目开发。
    在Node.js中，每次修改文件都要在命令行工具中重新执行该文件，非常繁琐。
```

######   		使用步骤：

```
    a.使用npm install nodemon –g 下载它
    b.在命令行工具中用nodemon命令替代node命令执行文件
```

######   		nodemon的作用：

```
    当我们修改文件的时候后不需要手动输入文件再执行，而是命令行自动帮我们执行修改后的文件，如果想要终止当前的nodemon，则按两次Ctrl+C,命令行中Ctrl+C是终止不是复制
```

#### 	4. 第三方模块nrm 

```
    nrm ( npm registry manager )：npm下载地址切换工具
    npm默认的下载地址在国外，国内下载速度慢
```

######   		使用方法： 

```
使用npm install nrm –g 下载它
查询可用下载地址列表 nrm ls
切换npm下载地址 nrm use 下载地址名称
```

#### 	5. 第三方模块gulp

##### 		a.什么是Gulp

```
    基于node平台开发的前端构建工具
    将机械化操作编写成任务, 想要执行机械化操作时执行一个命令行命令任务就能自动执行了
    用机器代替手工，提高开发效率。
```

##### 		b.Gulp能做什么

```
    项目上线，HTML、CSS、JS文件压缩合并
    语法转换（es6、less ...）
    公共文件抽离
    修改文件浏览器自动刷新  
```

##### 		c.Gulp使用  

```
    1.使用npm install gulp下载gulp库文件 

    2.在项目根目录下建立gulpfile.js文件

    3.重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件

    4.在gulpfile.js文件中编写任务.

    5.在命令行工具中执行gulp任务
```

##### 		d.Gulp当中提供的方法

```
    gulp.task('任务名称',callback)：建立gulp任务 callback是任务的回调函数

    gulp.src('获取的文件的位置以及文件名称')：获取任务要处理的文件

    gulp.dest('输出的位置')：输出文件

    gulp.watch()：监控文件的变化
```

##### 		e. Gulp插件

######   		1. 常用插件：

```
    a.gulp-htmlmin ：html文件压缩(npm install gulp-htmlmin)

    b.gulp-csso ：压缩css(npm install gulp-csso --save-dev)

    c.gulp-less: less语法转化(npm install gulp-less)

    d.gulp-babel ：JavaScript语法转化(npm install gulp-babel @babel/core @babel/preset-env)

    e.gulp-uglify ：压缩混淆JavaScript(npm install gulp-uglify)

    f.gulp-file-include ：公共文件包含(npm install gulp-file-include)

    g.browsersync ：浏览器实时同步
```

######   		2. Gulp插件的使用：  

```
    参考https://www.npmjs.com/，搜索插件名称，直接复制里面的使用代码

    1.通过npm这个命令去下载插

    2.在gulpfile.js这个文件当中引用这个插件 

    3.调用这个插件
```

######   		3. 构建任务   

```
	gulp.task('default',gulp.series('htmlmin','cssmin','jsmin','copy'));
```

###### 		4.案例：

```
    //引用变量
    const gulp=require('gulp');
    //引用插件
    const htmlmin = require('gulp-htmlmin');
    const fileinclude = require('gulp-file-include');
    const less = require('gulp-less');
    const csso = require('gulp-csso');
    const babel = require('gulp-babel');
    const uglify = require('gulp-uglify');
    //建立任务
    gulp.task('first',done=>{
        console.log('第一个gulp任务执行了');
        //获取要处理文件
        gulp.src('./src/css/base.css')
            .pipe(gulp.dest('dist/css'));//.pipe就是处理的意思，把要处理的代码放到里面
            //输出到dist/css里面，没有css这个文件就会自动创建
            done();
    });

    //注意 node执行的是一整个gulpfile.js文件，但是我想要执行的是某一个具体的task任务
    //如何执行task建立的任务
    /* 
    想要执行这个first任务，需要使用gulp提供的命令行工具
    通过输入npm install gulp-cli -g下载它
    下载完成之后，命令行工具就多出了一个gulp的命令 
    执行任务：gulp 任务名称  比如：gulp first
    */

    //html任务
    //1.html文件中代码的压缩操作 npm install gulp-htmlmin
    gulp.task('htmlmin',done=>{
        gulp.src('./src/*.html')//获取src下的所有html文件
        //2.抽取html文件中的公共部分 npm install gulp-file-include
        // 把公共部分引用回来：在原来剪切掉的页面的内容位置输入@@include('公共部分的位置')
            .pipe(fileinclude())//先抽取，再压缩
            //压缩代码;
            .pipe(htmlmin({ collapseWhitespace: true }))
            .pipe(gulp.dest('dist'));
        done();
    })

    //css任务
    //1.less语法转换
    gulp.task('cssmin',done=>{
        // 选择src目录下的所有less和css
        gulp.src(['./src/css/*.less','/src/css/*.css'])
            .pipe(less())
            .pipe(csso())//2.css代码压缩
            .pipe(gulp.dest('dist/css'));
        done();
    })

    // JS任务
    gulp.task('jsmin',done=>{
        gulp.src('./src/js/*.js')//选择所有的js文件
            //1.ES6代码转换
            .pipe(babel({
                presets: ['@babel/env']
                //可以判断当前代码的运行环境，将当前代码转为当前运行环境所支持的代码
            }))
            .pipe(uglify())
            //2.代码压缩
            .pipe(gulp.dest('dist/js'));
        done();
    })

    //复制文件夹
    gulp.task('copy',done=>{
        gulp.src('./src/images/*')
            .pipe(gulp.dest('dist/images'));
        gulp.src('./src/lib/*')
            .pipe(gulp.dest('dist/lib'));
        done();  
    })

    //构建任务
    gulp.task('default',gulp.series('htmlmin','cssmin','jsmin','copy'));
    //执行default的时候，依次执行数组里面的任务
```

### 三、Node.js中模块的加载机制

```
    1.模块查找规则-当模块拥有路径但没有后缀时
      require('./find.js');
      require('./find');
        1.require方法根据模块路径查找模块，如果是完整路径，直接引入模块。
        2.如果模块后缀省略，先找同名JS文件再找同名JS文件夹
        3.如果找到了同名文件夹，找文件夹中的index.js
        4.如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件
        5.如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到
    2.模块查找规则-当模块没有路径且没有后缀时
      require('find');
        1.Node.js会假设它是系统模块
        2.Node.js会去node_modules文件夹中
        3.首先看是否有该名字的JS文件
        4.再看是否有该名字的文件夹
        5.如果是文件夹看里面是否有index.js
        6.如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件
        7..否则找不到报错
```

### 四、package.json文件

#### 	1.node_modules文件夹的问题 

```
    1.文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢. 
    2.复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错
```

#### 	2. package.json文件的作用

```
	项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等，使用npm init -y命令生成。
```

```
   {
     "name": "description",//项目名称
     "version": "1.0.0",//项目的版本
     "description": "",//项目的描述，快速了解当前项目的作用和功能
     "main": "index.js",//项目主入口文件
     "scripts": {//存储的是命令的别名，想要执行某个任务的时候，执行命令的别名就可以了
     	"test": "echo \"Error: no test specified\" && exit 1",
        "build":"nodemon app.js" //使用的时候是npm run build
     },
     "keywords": [],//关键字，允许用关键字描述当前的项目
     "author": "",//项目作者
     "license": "ISC"//项目协议，默认协议，开放源代码
     "dependencies": {//当前项目所依赖的模块 项目依赖
         "formidable": "^1.2.2",
         "mine": "^0.1.0"
      }
     "devDependencies": {//开发依赖
     	"gulp": "^4.0.2"
      }
   }
```

#####     		1.开发人员使用npm install 命令下载全部的依赖，包括项目依赖和开发依赖

#####     		2.使用npm install --production 下载的是项目依赖

####   	3. 项目依赖

```
    1.在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖
    2.使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中
```

####   	4. 开发依赖

```
    1.在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖
    2.使用npm install 包名 --save-dev 命令将包添加到package.json文件的devDependencies字段中
```

####   	5. package-lock.json文件的作用 说明依赖关系

```
    1.锁定包的版本，确保再次下载时不会因为包版本不同而产生问题
    2.加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作
```

## 请求响应原理及HTTP协议

### 一、服务器端基础概念 

#### 	1.1 网站的组成  

```
    网站应用程序主要分为两大部分：客户端和服务器端。
    客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。
    服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。
```

#### 	1.2 Node网站服务器 

```
    能够提供网站访问服务的机器就是网站服务器，它能够接收客户端的请求，能够对请求做出响应
```

#### 	1.3 IP地址   

```
    互联网中设备的唯一标识。
    IP是Internet Protocol Address的简写，代表互联网协议地址.
```

#### 	1.4 域名  

```
    由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址。
    http://www.itheima.com => http://124.165.219.100/
    虽然在地址栏中输入的是网址, 但是最终还是会将域名转换为ip才能访问到指定的网站服务器。
```

#### 	1.5 端口

```
    端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。
```

#### 	1.6 URL  

```
    统一资源定位符，又叫URL（Uniform Resource Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。
```

#####   		1.URL的组成

```
    传输协议://服务器IP或域名:端口/资源所在位置标识
    http://www.itcast.cn(服务器IP或域名:端口)/news/20181018/09152238514.html
    http：超文本传输协议，提供了一种发布和接收HTML页面的方法。
```

#### 	1.7 开发过程中客户端和服务器端说明 

```
    在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑。
    本机域名：localhost
    本地IP：127.0.0.1
```

### 二、创建web服务器

```
     2.创建web服务器
    /* 示例代码 */
    // 1.引用系统模块
    const http = require('http');
    // 2.创建web服务器
    const app = http.createServer();//http.createServer()这个方法返回值是网站服务器对象
    // 3.当客户端发送请求的时候
    app.on('request', (req, res) => {//on()方法第一个参数是请求的事件名称,当有请求的时候执行事件处理函数
        //回调函数第一个参数保存了请求相关的信息，第二参数是响应
          //4.响应
         res.end('<h1>hi, user</h1>');
    });
    // 5.监听3000端口，一定要进行监听端口,随便填一个，习惯填3000
    app.listen(3000);
    console.log('服务器已启动，监听3000端口，请访问 localhost:3000')

    /* 6.访问：
    使用node命令去执行文件，文件执行之后网站服务器才能启动成功，然后就可以在浏览器去访问了
    一般使用nodemon，只要文件修改了救护自动执行
    1.nodemon 文件
    2.浏览器中输入：localhost:3000

```

### 三、HTTP协议

#### 	3.1 HTTP协议的概念

```
	超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器h架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。
就是如何在网站服务器中传送html文本到浏览器。
```

#### 	3.2 报文

```
	在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。
```

#### 	3.3 请求报文

#####   		1.请求方式 （Request Method）  

```
    GET 请求数据 在浏览器输入地址属于GET方式

    POST 发送数据 通过表单方式可以发送POST请求

    通过req.method;可以获取请求方式，这个是放在客户端发送请求里面的
```

#####   		2.请求地址 （Request URL）

```
    app.on('request', (req, res) => {//req:请求 res:响应
        req.headers // 获取请求报文
        req.headers['accept']);//获取请求报文信息的具体某一项
        req.url   // 获取请求地址
        req.method  // 获取请求方法
    });
```

#### 	3.4 响应报文

#####   		1.HTTP状态码 Status   

```
    在设置的时候res.writeHead(200);里面参数不写默认是200，根据当前情况设置状态码
    200 请求成功
    404 请求的资源没有被找到
    500 服务器端错误
    400 客户端请求有语法错误
```

#####   		2.内容类型 Type  

```
    res.writeHead(200,{
        'content-type':'text/plain'//纯文本，如果不指定内容类型默认是纯文本
        'content-type':'text/html;charset=utf8'//有时候还需要指定编码方式，否则会出现乱码
    });

    text/html
    text/css
    application/javascript
    image/jpeg
    application/json
```

### 四、HTTP请求与响应处理

#### 	4.1 请求参数

```
	客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。
```

#### 	4.2 GET请求参数

##### 		1.请求参数

```
     1.参数被放置在浏览器地址栏中，例如：http://localhost:3000/?name=zhangsan&age=20
     问号后面的就是请求参数
```

#####   		2.参数获取需要借助系统模块url，url模块用来处理url地址

```
	Node.js当中提供了内置模块，可以通过内置模块的方法来得到请求参数
```

######    			语法：

```javascript
    const url=require('url');//引入模块
    url.parse(req.url);//返回一个对象
    Url {
        protocol: null,
        slashes: null,
        auth: null,
        host: null,
        port: null,
        hostname: null,
        hash: null,
        search: '?name=zhangsan&&age=20',
        query: 'name=zhangsan&&age=20',
        pathname: '/index/',请求地址
        path: '/index/?name=zhangsan&&age=20',
        href: '/index/?name=zhangsan&&age=20'
    }
```

###### 			把查询参数解析成对象的形式   

```javascript
    url.parse(req.url，true);//把查询参数解析成对象的形式
        query: [Object: null prototype] 
        { 
            name: 'zhangsan',
            age: '20'
        }

    let params=url.parse(req.url,true).query;

    console.log(params.name);//name: 'zhangsan'

    console.log(params.age);//age: '20
```

##### 		3.案例

```javascript
    //引用系统模块
    const http = require('http');
    const url = require('url');
    // 创建web服务器
    const app = http.createServer(); //http.createServer()这个方法返回值是网站服务器对象
    //当客户端发送请求的时候
    app.on('request', (req, res) => {

        //req.method; 可以获取请求方式,是get还是post
        //console.log(req.method);

        //获取请求地址,其实就是一个标识，根据这个给客户端响应不同的内容
        // req.url
        // console.log(req.url);

        //获取请求报文信息
        //req.headers
        // console.log(req.headers);
        // console.log(req.headers['accept']);//获取请求报文信息的具体某一项

        //响应报文的HTTP状态码和内容类型
        res.writeHead(200, {
            /* 'content-type':'text/plain'//纯文本 */
            'content-type': 'text/html;charset=utf8'
        });

        //服务器端如何获取请求参数
        console.log(req.url);
        //以前我们可以通过截取字符串的方式来得到请求参数，但是在Node.js当中提供了内置模块，可以通过内置模块的方法来得到请求参数
        console.log(url.parse(req.url));
        //console.log(url.parse(req.url,true));
        /* let params=url.parse(req.url,true).query;
        console.log(params.name);
        console.log(params.age); */

        // 解决输入了请求参数之后，返回not found的问题
        // 使用对象解构的方式
        let {
            query,
            pathname
        } = url.parse(req.url, true);
        console.log(query.name);
        console.log(query.age);

        if (pathname == '/index' || pathname == '/') {
            //如果地址栏中localhost:3000/index或者是localhost:3000/就返回首页
            // res.end('<h2>welcome to homepage</h2>');
            res.end('<h2>欢迎来到首页</h2>');
        } else if (pathname == '/list') {
            res.end('welcome to listpage')
        } else {
            res.end('not found')
        }

        if (req.method == 'POST') {
            res.end('post');
        } else if (req.method == 'GET') {
            res.end('get')
        }
        //res.end('<h1>hi, user</h1>');
    })
    //监听端口
    app.listen(3000);
    console.log('网站服务器启动成功');
```

#### 	4.3 POST请求参数  

```
	两个问题：如何在客户端发送请求参数？如何在服务器端接收这些请求参数
```

#####   		1.参数被放置在请求体中进行传输 

```
	GET请求参数是放在地址栏中的，而POST是放在请求报文中传输的
```

#####   		2.获取POST参数需要使用data事件和end事件   

```javascriptz
    req.on('data',(params)=>{//post参数是一步一步接收的，会持续触发data事件
        postParams+=params;
    });
    req.on('end',()=>{
       console.log(postParams);//输出的是一个字符串
    });
```

#####   		3.使用querystring系统模块将参数转换为对象格式

```
	querystring系统模块是用来处理post请求参数的，把字符串转换成对象格式
```

##### 		4.案例代码

```javascript
    //引用系统模块
    const http = require('http');
    // 创建web服务器
    const app = http.createServer(); //http.createServer()这个方法返回值是网站服务器对象
    //处理请求参数的模块
    const querystring=require('querystring');
    //当/客户端发送请求的时候
    app.on('request', (req, res) => {
        //post参数是通过事件的方式接收的
        //data 当请求参数传递的时候触发data事件
        //end 当参数传递完成的时候发出end事件

        let postParams='';
        req.on('data',(params)=>{
            postParams+=params;
        });

        req.on('end',()=>{
            console.log(querystring.parse(postParams));
            //console.log(postParams);
        });

        res.end('ok');
    })

    //监听端口
    app.listen(3000);
    console.log('网站服务器启动成功');
```

#### 	4.4 路由

```
    路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。
    route->app.js
```

```javascript
    const http=require('http');//引入
    const url=require('url');
    const app=http.createServer();//创建
    //添加请求事件
    app.on('request',(req,res)=>{
        // 实现路由功能
        const method=req.method.toLowerCase();
        //获取请求地址
        const pathname=url.parse(req.url).pathname;

        res.writeHead(200,{
            'content-type':'text/html;charset=utf8'
        })
        //地址判断
        if (method=='get') {
            if(pathname=='/'||pathname=='/index'){
                res.end('欢迎来到首页');
            }else if (pathname=='list'){
                res.end('欢迎来到列表页')
            }else{
                res.end('你访问的页面不存在')
            }
        } else if(method=='post'){
            if(pathname=='/'||pathname=='/index'){
                res.end('欢迎来到首页');
            }else if (pathname=='list'){
                res.end('欢迎来到列表页')
            }else{
                res.end('你访问的页面不存在')
            }
        }
    })

    //监听端口
    app.listen(3000);
    console.log('服务器启动成功')
```

#### 	4.5 静态资源

```
    服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件
    静态资源访问：static
```

##### 		请求静态资源案例

```javascript
    const http = require('http'); //引入
    const url = require('url');
    const path = require('path');
    const app = http.createServer(); //创建
    const fs = require('fs');
    const mime=require('mime');
    //添加请求事件
    app.on('request', (req, res) => {
        //获取到请求路径，再转换为文件在服务器中的真实路径，然后读取这个内容，把内容返回给客户端
        let pathname = url.parse(req.url).pathname; //获取请求路径
        pathname = pathname == '/' ? '/default.html' : pathname; //什么都不输入默认往首页
        //获取当前文件所在的绝对路径,拼接路径使用path模块
        let realpath = path.join(__dirname, 'public' + pathname); //转换为服务器的硬盘路径
        let type=mime.getType(realpath);//使用第三方模块mime可以获取当前文件的类型
        //读取文件内容
        fs.readFile(realpath, (error, result) => {
            //文件读取失败处理
            if (error != null) {
                res.writeHead(404, {
                    'content-type': 'text/html;charset=utf8'
                });
                res.end('文件读取失败');
                return;
            }
            res.writeHead(200,{
                'content-type':type//传递当前文件的类型
            });
            res.end(result); //把内容返回
        })
    })
    //监听端口
    app.listen(3000);
    console.log('服务器启动成功')
```

#### 	4.6 动态资源  

```
    相同的请求地址不同的响应资源，这种资源就是动态资源。
    http://www.itcast.cn/article?id=1
    http://www.itcast.cn/article?id=2
    地址相同但是传递的参数不同
```

### 五、Node.js异步编程 

####  	5.1 同步API和异步API

```javascript
    同步API：只有当前API执行完成后，才能继续执行下一个API
          console.log('before'); 
          console.log('after');
          依次输出

    异步API：当前API的执行不会阻塞后续代码的执行
          console.log('before');
          setTimeout(
            () => { console.log('last');
          }, 2000);
          console.log('after');
          输出before after last
```

####   	5.2 同步API, 异步API的区别（ 获取返回值 ）

```javascript
    同步API可以从返回值中拿到API执行的结果, 但是异步API是不可以的

    // 同步
        function sum (n1, n2) { 
          return n1 + n2;
        } 
        const result = sum (10, 20);

    // 异步
        function getMsg () { 
          setTimeout(function () { 
            return { msg: 'Hello Node.js' }
          }, 2000);
        }
        const msg = getMsg ();
        //返回的是undefined,因为当程序执行的时候，等待两秒后才会返回{ msg: 'Hello Node.js' }，但是console.log(msg)是直接输出的，当程序未执行完是默认返回undefined
```

####  	5.3 回调函数

#####   		自己定义函数让别人去调用

```javascript
     function getData(callback){
          callback('123');
        }

     getData(function(n){
          console.log('callback被执行了');
          console.log(n);//123
     });
```

#### 	5.4 使用回调函数获取异步API执行结果    

```javascript
    function getMsg (callback) { 
        setTimeout(function () { 
          callback( { 
            msg: 'Hello Node.js'
          })
          }, 2000);
        }

    getMsg(function(data){
         console.log(data);//可以拿到返回值
        })
```

#### 	5.5 同步API, 异步API的区别（代码执行顺序）    

```javascript
    1.同步API从上到下依次执行，前面代码会阻塞后面代码的执行
        for (var i = 0; i < 100000; i++) { 
          console.log(i);
        }
        console.log('for循环后面的代码');//for循环执行完之后才执行

    2.异步API不会等待API执行完成后再向下执行代码
        console.log('代码开始执行'); 
        setTimeout(() => { console.log('2秒后执行的代码')}, 2000);
        setTimeout(() => { console.log('"0秒"后执行的代码')}, 0); 
        console.log('代码结束执行');
        //代码开始执行 代码结束执 "0秒"后执行的代码 2秒后执行的代
```

#### 	5.6 代码执行顺序分析

```
	与JS执行机制相似，参考
```

#### 	5.7 Node.js中的异步API

#####   		文件读取：    

```
	fs.readFile('./demo.txt', (err, result) => {});
```

#####  		事件监听:

```
    var server = http.createServer();
    server.on('request', (req, res) => {});
```

```javascript
    如果异步API后面代码的执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题要怎么解决呢？
        fs.readFile('./demo.txt', (err, result) => {});
        console.log('文件读取结果');
        // 需求:依次读取123文件 回调地狱
          const fs=require('fs');
          fs.readFile('./1.txt','utf8',(err,result1)=>{
            console.log(result1);
            fs.readFile('./2.txt','utf8',(err,result2)=>{
              console.log(result2);
              fs.readFile('./3.txt','utf8',(err,result3)=>{
                console.log(result3);
              })
            });
          });
```

####   	5.8 Promise

```
 Promise出现的目的是解决Node.js异步编程中回调地狱的问题。
```

#####     		promise   

```javascript
     const fs=require('fs');
        let promise=new Promise((resolve,reject)=>{
          fs.readFile('./11.txt','utf8',(err,result)=>{
            if(err!=null){
              reject(err);
            }else{
              resolve(result);//成功也就是调用then方法里面的匿名函数
                //resolve实际上是一个函数，当异步API有返回结果的时候，调用它，并且把异步API的执行结果通过参数的形式传出去
            }
          })
        });
        //接收异步API的执行结果 promise.then  promise.catch
        promise.then((result)=>{
          console.log(result);
        })
        .catch((err)=>{
          //也是一个函数，异步API执行失败，把失败的结果传到promise外面
          console.log(err);
        })
```

#####     		promise解决回调地狱 promise2   

```javascript
    const fs=require('fs');
        function p1() {
          return new Promise((resolve, reject) => {
            fs.readFile('./1.txt', 'utf8', (err, result) => {
              resolve(result);
            });
          });
        }
        function p2() {
          return new Promise((resolve, reject) => {
            fs.readFile('./2.txt', 'utf8', (err, result) => {
              resolve(result);
            });
          });
        }
        function p3() {
          return new Promise((resolve, reject) => {
            fs.readFile('./3.txt', 'utf8', (err, result) => {
              resolve(result);
            });
          });
        }
        p1().then((r1) => {
            console.log(r1);
            return p2();//链式编程，每一次结束之后调用下一个函数，返回promise对象
         })
          .then((r2) => {
            console.log(r2);
            return p3();
          })
          .then((r3) => {
            console.log(r3);
          })
```

####   5.9 异步函数 ES7新增语法

```
异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。   
语法：
    const fn = async () => {};
    async function fn () {}
```

######  	注意   

```
    1.在普通函数定义的前面加上async关键字
    2.异步函数默认的返回值是promise对象a
    3. 在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法
    4. 在异步函数内部使用throw关键字抛出程序异常
    5. 调用异步函数再链式调用then方法获取异步函数执行结果
    6. 调用异步函数再链式调用catch方法获取异步函数执行的错误信息
    7.await关键字
```

######  	await关键字    

```
    只能出现在异步函数中
    await promise 它可以暂停异步函数的执行，等待promise对象返回结果后再向下执行函数
    1. await关键字只能出现在异步函数中
    2. await promise  await后面只能写promise对象 写其他类型的API是不不可以的
    3. await关键字可是暂停异步函数向下执行 直到promise返回结果
```

####   	5.10 改造依次读取文件

```javascript
    const fs=require('fs');
    const promisify=require('util').promisify;
    //promisify是util这个模块下的一个方法，它对现有的异步API进行包装，使它能够返回一个promise对象，以支持异步函数的语法
    const readFile=promisify(fs.readFile);
    async function run(){
        let r1=await readFile('./1.txt','utf8',);
        let r2=await readFile('./2.txt','utf8',);
        let r3=await readFile('./3.txt','utf8',);
        console.log(r1);
        console.log(r2);
        console.log(r3);
    }
    run();
```

# MongoDB

## MongoDB

### 一、数据库概述

#### 	1. 为什么要使用数据库

```
    动态网站中的数据都是存储在数据库中的
    数据库可以用来持久存储客户端通过表单收集的用户信息
    数据库软件本身可以对数据进行高效的管理
```

#### 	2. 什么是数据库

```
    数据库即存储数据的仓库，可以将数据进行有序的分门别类的存储。它是独立于语言之外的软件，可以通过API去操作它。
    常见的数据库软件有：mysql、mongoDB、oracle。
```

#### 	3. 数据库相关概念

```
    在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据）。
    database：数据库，mongoDB数据库软件中可以建立多个数据库
    collection：集合，一组数据的集合，可以理解为JavaScript中的数组
    document：文档，一条具体的数据，可以理解为JavaScript中的对象 一条一条的数据json 
    field：字段，文档中的属性名称，可以理解为JavaScript中的对象属性
```

### 二、数据库环境搭建

#### 	2.1 MongoDB数据库下载安装

```
	下载地址：https://www.mongodb.com/download-center/community
```

#### 	2.2 MongoDB可视化软件

```
    MongoDB可视化操作软件，是使用图形界面操作数据库的一种方式。
    MongoDB Compass:https://www.mongodb.com/download-center/compass
```

### 三、MongoDB数据库连接

#### 	3.1 Mongoose第三方包 

```
    使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose
    使用npm install mongoose命令下载
```

#### 	3.2 启动MongoDB  

```
    在命令行工具中运行net start mongoDB即可启动MongoDB，否则MongoDB将无法连接。
    关闭：net stop mongoDB
```

#### 	3.3 数据库连接

```
  使用mongoose提供的connect方法即可连接数据库。
```

#####   		语法：

```
	mongoose.connect('数据库的地址和数据库的名称',{ useNewUrlParser: true })
```

```
    //使用mongodb协议
    const mongoose=require('mongoose');
    mongoose.connect('mongodb://localhost/playground',{ useNewUrlParser: true })
       .then(()=>{//成功执行这个代码
           console.log('数据库连接成功')
        })
       .catch((err)=>{//失败执行这个代码
           console.log(err,'数据库连接失败')
        })
```

#### 	3.4 创建数据库

```
	在MongoDB中不需要显式创建数据库，如果正在使用的数据库不存在，MongoDB会自动创建。
```

### 四、MongoDB增删改查操作

#### 所有和数据库操作相关的都是异步操作

#### 	4.1 创建集合  

```
	创建集合分为两步，一是对对集合设定规则，二是创建集合，创建mongoose.Schema构造函数的实例即可创建集合。
```

#####   		1.设定集合规则  

```
    创建集合也就是创建mongoose.Schema(传递一个对象)构造函数的一个实例对象
      const courseSchema = new mongoose.Schema({
        name: String,//当前字段和对应的类型
        author: String,
        isPublished: Boolean
      });
```

#####   		2.创建集合并应用规则 

```
    使用集合创建规则 mongoose.model('集合的名称',使用的规则)
      const Course = mongoose.model('Course', courseSchema); 
        // Course是集合(collection)的名称,首字母是大写，但是在数据库中它是小写的而且是courses
        //返回值是一个构造函数代表当前集合，可以使用构造函数下面的方法来进行各种各样的操作
```

#### 	4.2 创建文档(就是插入数据)

  创建文档实际上就是向集合中插入数据。

#####   		第一种方法：const course = new Course({})

```
    分为两步：
        // 1.创建集合实例
        const course = new Course({
          name: 'Node.js course',//里面的数据类型要和前面的规则相对应
          author: '黑马讲师',
          isPublished: true
        });

        //2.调用实例对象下的save方法将数据保存到数据库中
        course.save();
```

#####   		第二种方法：Course.create({对象},回调函数)   

```
    //通过回调函数获取异步API的执行结果
        Course.create({
            name: 'JavaScript基础', //对象
            author: '黑马讲师',
            isPublish: true
          },
          (err, doc) => { //回调函数
            // 错误对象
            console.log(err)//null
            // 输出的是当前插入的文档当前插入的文档
            console.log(doc)
          });

    //支持Promise方法，返回promise对象,也就是支持异步函数的方法
        Course.create({name: 'JavaScript基础', author: '黑马讲师', isPublish: true})
          .then(doc => console.log(doc))
          .catch(err => console.log(err))
```

#### 	4.3 mongoDB数据库导入数据  

```
    找到mongodb数据库的安装目录，将安装目录下的bin目录放置在环境变量中。
    mongoimport –d 数据库名称 –c 集合名称 –-file 要导入的数据文件
    数据库名称:就是你创建的那个数据库
    集合名称：你要把导进去的数据放在哪个集合中，比如users 对应数据库中的，是小写复数的
    要导入的数据文件：要指明数据文件在哪个文件夹，比如./当前文件夹

    mongoimport -d playground -c users --file ./user.json
```

#### 	4.4 查询文档

#####   		1.根据条件查找文档（条件为空则查找所有文档） Course.find()  

```
    Course.find().then(result => console.log(result))

        a.Course.find().then() 
         返回文档集合,以数组的形式存储，返回Course里面的所有文档
        [{
          _id: 5c0917ed37ec9b03c07cf95f,
          name: 'node.js基础',
          author: '黑马讲师‘
        },{
          _id: 5c09dea28acfb814980ff827,
          name: 'Javascript',
          author: '黑马讲师'
        }]

        b.Course.find({查找的条件，例如_id:'5c09f267aeb04b22f8460968'}).then()
         返回的是为指定id的文档，是一个数组的形式，没有找到的话是一个空数组
```

#####   		2.根据条件查找文档 Course.findOne({}).then()  

```
    Course.findOne().then()
        a.Course.findOne().then()
         不传条件默认返回的是当前集合的第一条数据

        b.Course.findOne({name: 'node.js基础'}).then(result => console.log(result))
        // 返回文档 注意这里返回的是一条,就是一个对象，不是数组
        {
          _id: 5c0917ed37ec9b03c07cf95f,
          name: 'node.js基础',
          author: '黑马讲师‘
        }
```

##### 		3.范围查询

###### 			a.大于$gt 小于$lt 

```
    User.find({age: {$gt: 20, $lt: 50}}).then(result => console.log(result)) 
        查询年龄大于20小于50的文档
```

###### 			b.匹配包含 $in

```
	User.find({hobbies: {$in: ['敲代码']}}).then(result => console.log(result))
    爱好包含敲代码的文档
```

###### 			c.选择要查询的字段 User.find().select().then()    

```
    User.find().select('name email').then(result => console.log(result))
        查询结果是集合里面所有文档的name email 和_id

        如果不想要某一个字段可以使用 -_字段名
        User.find().select('name email -_id').then(result => console.log(result))
        查询结果是集合里面所有文档的name email 没有_id
```

###### 			d.将数据进行排序User.find().sort().then()    

```
    User.find().sort('age').then(result => console.log(result))
        将数据按照年龄排序从小到大，升序排列,默认升序
        User.find().sort('-age').then(result => console.log(result))
        将数据按照年龄排序从大到小，降序排列
```

###### 			e.User.find().skip().limit().then()

```
    skip 跳过多少条数据 limit 限制查询数量
        User.find().skip(2).limit(2).then(result => console.log(result))
        跳过前两条数据，只查询两条
```

#### 	4.5 删除文档

#####   		1.删除单个 findOneAndDelete()  

```
    User.findOneAndDelete({}).then(result => console.log(result))

    如果查询的结果有多个会将第一个删除，返回promise对象，.then接收删除哪个文档就返回哪个文档
```

#####   		2.删除多个deleteMany()

```
    User.deleteMany({}).then(result => console.log(result))
    传入一个空对象，会删除User里面的所有文档
    返回一个对象：
    { n: 5, ok: 1, deletedCount: 5 }，删除了五个文档，操作成功
```

#### 	4.6 更新文档(修改)

#####   		1.更新单个  

```
    User.updateOne({查询条件}, {要修改的值}).then(result => console.log(result))
    返回一个对象，对象中包含了是否修改成功的信息
        { n: 1, nModified: 1, ok: 1 }
```

#####   		2.更新多个  

```
	User.updateMany({查询条件}, {要更改的值}).then(result => console.log(result))
```

#### 	4.7 mongoose验证

#####   		1.验证规则

​	在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败。

```javascript
    const postSchema = new mongoose.Schema({
        title:{
           type:String/Number/Data/Boolean

           required: true 必传字段
            required: [true,'请写入必写字段'] 
            //失败时会显示后面的代码（错误信息），后面每一项都可以自定义错误信息

           minlength：3 字符串最小长度
           maxlength: 20 字符串最大长度

           min: 2 数值最小为2
           max: 100 数值最大为100

           enum: ['html', 'css', 'javascript', 'node.js']
             //所传的值必须是中括号里面的取值

           trim: true 去除字符串两边的空格

           default: 默认值
              default:Data.now(当前的时间)

           validate: 自定义验证器
             author:{
               type:String,
               validate:{
                validator:v=>{
                  //返回的是一个布尔值，true代表验证成功，false代表失败
                  //v表示的是要验证的值
                  return v&&v.length>4
                  //当有v传入并且v的长度大于4时就是合法的，返回true
                },
                message:'传入的值不符合规则'
                //自定义错误信息
              }
            }
        }
     })
```

##### 		2.获取错误信息：

###### 		语法：

```
	error.errors['字段名称'].message
```

```
    Post.creat({...})
         .then(result=>console.log(result))
         .catch(error=>{
            const err=error.errors;//获取错误信息对象
            for(var attr in err){//循环错误信息
               console.log(err[attr]['message']);//将错误信息打印到控制台
            }
         })
```

#### 	4.8 集合关联

  通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。

##### 		1.步骤

```
    使用id对集合进行关联
    使用populate方法进行关联集合查询
```

##### 		2.集合关联的实现

###### 		语法：mongoose.Schema.Types.ObjectId, ref: '关联的集合' 

```
    // 用户集合
    const User = mongoose.model('User', new mongoose.Schema({ name: { type: String } })); 
    // 文章集合
    const Post = mongoose.model('Post', new mongoose.Schema({
         title: { 
            type: String 
         },
         // 使用ID将文章集合和作者集合进行关联
         author: { 
            type: mongoose.Schema.Types.ObjectId, ref: 'User' 
         }
          //这个type是一个固定写法
         //ref: 'User' 要与哪个集合进行关联就写哪一个
    }));

    //联合查询 Post.find().populate()
     Post.find()
       .populate('author')
       .then((err, result) => console.log(result));
```

## 模板引擎

### 一、模板引擎的基础概念

####   	1.1 模板引擎

​    模板引擎是第三方模块。

​    让开发者以更加友好的方式拼接字符串，使项目代码更加清晰、更加易于维护。

####   	1.2 art-template模板引擎  

```
    1.在命令行工具中使用 npm install art-template 命令进行下载

    2.使用const template = require('art-template')引入模板引擎
         返回的是一个方法，这个方法就是用来拼接字符串的

    3.告诉模板引擎要拼接的数据和模板在哪 
         const html = template(‘模板绝对路径’, 数据); 
         有两个参数，第一个是绝对路径，第二个是一个对象，用来存放要展示的数据
         template方法返回值就是一个拼接好的字符串

    4.使用模板语法告诉模板引擎，模板与数据应该如何进行拼接 
```

####   	1.3 art-template代码示例

```
    // 导入模板引擎模块
        const template = require('art-template');
    // 将特定模板与特定数据进行拼接
        const html = template('./views/index.art',{//后缀名为art
          data: {//第二个参数是一个对象的形式存储的
            name: '张三',
            age: 20
          }
        }); 
```

```html
      <div>
            <span>{{data.name}}</span>
            <span>{{data.age}}</span>
        </div>
```

### 二、模板引擎的语法

#### 	2.1 模板语法

​    art-template同时支持两种模板语法：标准语法和原始语法。

​    标准语法可以让模板更容易读写，原始语法具有强大的逻辑处理能力。

​    标准语法： {{ 数据 }}

​    原始语法：<%=数据 %>

#### 	2.2 输出

​    将某项数据输出在模板中，标准语法和原始语法如下：

##### 		标准语法：{{ 数据 }}

```
    <!-- 标准语法 -->
    <h2>{{value}}</h2>
    <h2>{{a ? b : c}}</h2>
    <h2>{{a + b}}</h2>
```

##### 		原始语法：<%=数据 %>

```
    <!-- 原始语法 -->
    <h2><%= value %></h2>
    <h2><%= a ? b : c %></h2>
    <h2><%= a + b %></h2>
```

#### 	2.3 原文输出

如果数据中携带HTML标签，默认模板引擎不会解析标签，会将其转义后输出。

##### 		标准语法：{{@ 数据 }}

```
	<h2>{{@ value }}</h2>
```

##### 		原始语法：<%-数据 %>

```
	<h2><%- value %></h2>
```

####   	2.4 条件判断

​    再模板中可以根据条件来决定显示哪块HTML代码

##### 		标准语法

```
    1.只有一个条件
    {{if 条件}} 
        符合条件显示的内容 
    {{/if}
    2.多分支条件
    {{if v1}} 
        ... 
    {{else if v2}} 
        ...
    {{else}} 
        ... 
    {{/if}}
```

##### 		原始语法

```
    <% if (value) { %> ... <% } %>

    <% if (v1) { %> ... <% } else if (v2) { %> ... <% } %>

    原始语法的一大好处就是尖括号之间可以写原生的js代码
```

#### 	2.5 循环语法

##### 		1.标准语法：{{each 数据}} {{/each}}

```
    {{each target}}
        {{$index}} {{$value}}
    {{/each}}
```

##### 		2.原始语法：<% for() { %> <% } %>

```
     <% for(var i = 0; i < target.length; i++){ %>
          <%= i %> <%= target[i] %>
     <% } %>
```

#### 	2.6 子模板

​    使用子模板可以将网站公共区块(头部、底部)抽离到单独的文件中。

##### 		1.标准语法：{{include '模板'}}

​    <!-- 标准语法 -->

​    {{include './header.art'}}

##### 		2.原始语法：<%include('模板') %>

​    <!-- 原始语法 -->

​    <% include('./header.art') %>

#### 	2.7 模板继承

​    使用模板继承可以将网站HTML骨架抽离到单独的文件中，其他页面模板可以继承骨架文件。

##### 		骨架文件：

​    可以留下三个位置分为用来填充CSS、JS和页面主体内容

##### 		页面模板：

​    继承了骨架模板，继承的时候在预留的位置填充上相应的文件

#####  		语法：

```
    1.预留位置：
        {{block '名字'}}{{/block}}
        在特定的位置添加block,每个不同的位置用名字来区分

    2.继承和填充
        {{extend '要继承的文件'}}
        {{block 'head'}} 文件的链接 {{/block}}
```

####   	2.8 模板继承示例

```
     <!doctype html>
       <html>
          <head>
                    <meta charset="utf-8">
            <title>HTML骨架模板</title>
            {{block 'head'}}{{/block}}
          </head>
          <body>
            {{block 'content'}}{{/block}}
          </body>
        </html>
        <!--index.art 首页模板-->

        {{extend './layout.art'}}

        {{block 'head'}} <link rel="stylesheet" href="custom.css"> {{/block}}

        {{block 'content'}} <p>This is just an awesome page.</p> {{/block}}  
```

#### 	2.9 模板配置

##### 		1.向模板中导入变量 template.defaults.imports.变量名 = 变量值;   

```
 	将某一个方法当作是一个变量引入到模板中
```

##### 		2.设置模板根目录 template.defaults.root = 模板目录

```javascript
    template.defaults.root=path.join(__dirname, 'views');
    const html = template('06.art', {
        //view目录下的06.art文件
    });
```

##### 		3.设置模板默认后缀 template.defaults.extname = '.art'    

```javascript
    const html = template('06', {
        //不用写art了
    });
```

#### 	2.10 第三方模块router 

##### 		功能：实现路由

##### 		下载：npm install router

##### 		使用步骤： 

```javascript
    1.获取路由对象
    2.使用路由对象提供的方法创建路由
    3.启用路由，使路由生效
         1. 获取路由对象
          const getRouter = require('router')
         2. 使用路由对象提供的方法创建路由
          const router = getRouter();
            //请求方式为get,请求地址为/add，第二个参数是处理请求的函数`  
             router.get('/add', (req, res) => {
                res.end('Hello World!')
              }) 
               //请求方式为post,请求地址是/add，第二个参数是处理请求的函数
                //router.post('/add', (req, res) => {
                  res.end('Hello World!')
              }) 
         3. 启用路由
          server.on('request', (req, res) => {//服务
            router(req, res,()=>{
             //请求完成之后调用这个函数,必选参数，可以填一个空函数
           })
          })
```

#### 	3.4 第三方模块 serve-static

##### 		功能：实现静态资源访问服务

##### 		下载：npm install server-static

##### 		步骤：  

```javascript
    1.引入serve-static模块获取创建静态资源服务功能的方法
    2.调用方法创建静态资源服务并指定静态资源服务目录
    3.启用静态资源服务功能
        示例代码：
        1.引入serve-static模块获取创建静态资源服务功能的方法
        const serveStatic = require('serve-static')
        2.调用方法创建静态资源服务并指定静态资源服务目录
        const serve = serveStatic('public')
        3.启用静态资源服务功能
        server.on('request', () => { 
            serve(req, res)
        })
        server.listen(3000)
```

# Express

## 一、Express框架简介及初体验

### 	1.1 Express框架是什么    

```
    Express是一个基于Node平台的web应用开发框架，是Node的第三方模块，它提供了一系列的强大特性，帮助你创建各种Web应用。我们可以使用 npm install express 命令进行下载。
```

### 	1.2 Express框架特性 

```
    1.提供了方便简洁的路由定义方式
    2.对获取HTTP请求参数进行了简化处理
    3.对模板引擎支持程度高，方便渲染动态HTML页面
    4.提供了中间件机制有效控制HTTP请求
    5.拥有大量第三方中间件对功能进行扩展
```

### 	1.3 原生Node.js与Express框架对比之路由

#### 		a.原生Node.js

```javascript
      app.on('request', (req, res) => {
          // 获取客户端的请求路径
          let { pathname } = url.parse(req.url);
          // 对请求路径进行判断 不同的路径地址响应不同的内容
          if (pathname == '/' || pathname == 'index') {
               res.end('欢迎来到首页');
          } else if (pathname == '/list') {
               res.end('欢迎来到列表页页');
          } else if (pathname == '/about') {
               res.end('欢迎来到关于我们页面')
          } else {
               res.end('抱歉, 您访问的页面出游了');
          }
       });
```

### 		b.Express框架

```javascript
            // 当客户端以get方式访问/时
        app.get('/', (req, res) => {
             // 对客户端做出响应
             res.send('Hello Express');
        });

        // 当客户端以post方式访问/add路由时
        app.post('/add', (req, res) => {
             res.send('使用post方式请求了/add路由');
        });
```

### 	1.4 原生Node.js与Express框架对比之获取请求参数

#### 		1.Node.js

```javascript
    app.on('request', (req, res) => {
        // 获取GET参数
        let {query} = url.parse(req.url, true);

        // 获取POST参数
        let postData = '';
        req.on('data', (param) => {
             postData += param;
        });
        req.on('end', () => {
             console.log(querystring.parse(postData)
         })); 
    });
```

#### 		2.Express框架

```javascript
    app.get('/', (req, res) => {
        // 获取GET参数
        console.log(req.query);
    });

    app.post('/', (req, res) => {
         // 获取POST参数
         console.log(req.body);
    }) 
```

### 	1.5 Express初体验

使用Express框架创建web服务器及其简单，调用express模块返回的函数即可。

```javascript
    //引入Express框架
    const express = require('express');
    // 使用框架创建web服务器
    const app = express();

    // 当客户端以get方式访问/路由时
    app.get('/', (req, res) => {
         // 对客户端做出响应 send方法会根据内容的类型自动设置请求头
         res.send('Hello Express'); // <h2>Hello Express</h2> {say: 'hello'}
         //send()方法：
         // 1. send方法内部会检测响应内容的类型
         // 2. send方法会自动设置http状态码
         // 3. send方法会帮我们自动设置响应的内容类型及编码
    });
    // 程序监听3000端口
    app.listen(3000);
```

## 二、Express中间件

### 	2.1 什么是中间件

#### 		1.什么是中间件   

```
	中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。
```

#### 		2.中间件的构成

```
    中间件主要由两部分构成，中间件方法以及请求处理函数。
    中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。
    app.get('请求路径', '处理函数')   // 接收并处理get请求
    app.post('请求路径', '处理函数')  // 接收并处理post请求
```

#### 		3.设置多个中间件   

```javascript
    可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。
    默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。
    可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。
    app.get('/request', (req, res, next) => {
         req.name = "张三";
         next();//这里一定要调用
    });

    app.get('/request', (req, res) => {
         res.send(req.name);
    });
```

### 	2.2 app.use中间件用法

```javascript
    app.use 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。
    app.use((req, res, next) => {
        console.log(req.url);
        next();
    });

    app.use 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。
    app.use('/admin', (req, res, next) => {
        console.log(req.url);
        next();
    });
```

### 	2.3 中间件的应用

####     		1.路由保护

```javascript
    客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。

    app.use('/admin',(req,res,next)=>{
        let isLogin=true;
        if(isLogin){
             next();//如果登录了就可以访问下一个页面
         }else{
             res.send('您还未登录')
         }
    })

    app.get('/admin',(req,res)=>{
        res.send('您已登录，可以访问当前页面');
    })
```

#### 		2.网站维护公告

```javascript
    在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。
    写在最前面
    app.use((req,res,next)=>{
        res.send('当前网站正在维护')
        /无论输入什么地址都是显示网站正在维护，因为没有调用next，程序运行到这里就终止了
    })
```

#### 		3.自定义404页面

```javascript
    发生错误时需要提出警告，写在最后面
    app.use((req,res,next)=>{
         //更改状态码  res.status(404);
         //更改状态码和显示提示信息
         res.status(404).send('您访问的页面不存在');
    })
```

### 	2.4 错误处理中间件

```
    在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。
    错误处理中间件是一个集中处理错误的地方。
```

#### 		1.定义错误处理中间件  只能处理同步代码

```javascript
    app.use((err, req, res, next) => {
        res.status(500).send('服务器发生未知错误');
    })

    案例：
    app.get('/index',(req,res)=>{
        throw new Error('程序发生了未知错误');//抛出一个错误
        res.send('程序正常执行');//抛出错误之后这里就不能执行了，没有抛出错误就能执行
    })
    //错误处理中间件
    app.use((err,req,res,next)=>{
        res.status(500).send(err.message)//err.message存储的就是Error的错误信息
    })
```

#### 		2.手动触发触发错误处理中间件  异步API

```javascript
    当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件。

    app.get("/", (req, res, next) => {
        fs.readFile("/file-does-not-exist", (err, data) => {
            if (err) {
                next(err);//传递了参数表示要触发错误处理中间件，把err传递给了错误处理中间件
            }else{
                res.send(result);
            }
         });
    });
    //错误处理中间件
    app.use((err,req,res,next)=>{
        res.status(500).send(err.message)//err.message存储的就是Error的错误信息
    })
```

### 	2.5 异步函数捕获错误

```
    在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。
    异步函数执行如果发生错误要如何捕获错误呢？

    try catch 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。
```

```javascript
    示例代码：
    app.get("/", async (req, res, next) => {
        try {//把可能会出错的代码块放在这一块里面，出错执行catch,没有出错执行catch 后面的
            await User.find({name: '张三'})
        }catch(ex) {//发生错误时会执行这里的代码，这个参数实际上就是错误信息，可以手动调用错误处理中间件
            next(ex);
        }
    });
```

## 三、Express框架请求处理

### 	3.1 构建模块化路由

```
	可以根据某种条件对路由进行分类，不把路由全部放在同一个模块，方便管理
```

##### 		1.创建路由基础代码

```javascript
    const express = require('express') 
    // 创建路由对象
    const home = express.Router();//用来创建路由，返回值是一个路由对象
    // 将路由和请求路径进行匹配
    app.use('/home', home);当访问地址是/home的时候就调用home路由
         //一级路由没有添加请求处理函数，具体的请求处理函数需要在二级路由添加
         // 在home路由下继续创建路由
    home.get('/index', () => {
         //  当用户访问/home/index这个页面的时候,显示下方的代码
         res.send('欢迎来到博客展示页面');
    });
```

##### 		2.如何构建模块化路由

```javascript
    a.
    // home.js
    const home = express.Router(); 
    home.get('/index', () => {
         res.send('欢迎来到博客展示页面');
    });
    module.exports = home;
```

```javascript
    b.
    // admin.js
    const admin = express.Router();
    admin.get('/index', () => {
          res.send('欢迎来到博客管理页面');
    });
    module.exports = admin;
```

```javascript
    c.
    // app.js
    const home = require('./route/home.js');
    const admin = require('./route/admin.js');
    app.use('/home', home);
    app.use('/admin', admin);
```

### 	3.2 GET参数的获取

```javascript
    Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。

    示例代码：
    // 接收地址栏中问号后面的参数
    // 例如: http://localhost:3000/?name=zhangsan&age=30
    app.get('/', (req, res) => {
        console.log(req.query); // {"name": "zhangsan", "age": "30"}
    });
```

### 	3.3 POST参数的获取

##### 		1.body-parser

```
	Express中接收post请求参数需要借助第三方包 body-parser
```

##### 		2.下载

```
	npm install body-parser
```

##### 		3. 示例代码

```javascript
    // 引入body-parser模块
    const bodyParser = require('body-parser');

    // 配置body-parser模块
    app.use(bodyParser.urlencoded({ extended: false }));
        bodyParser.urlencoded({ extended: false })这个方法返回的是一个函数
        extended: false 这是一个必填参数，为false的时候表示的是使用querystring方法处理请求此参数的格式
        extended: true 方法内部使用第三方模块qs处理请求参数的格式

    // 接收请求
    app.post('/add', (req, res) => {
        // 接收请求参数
        console.log(req.body);body属性是bodyParser添加的属性，里面存放的是请求参数
    }) 
```

### 	3.4 Express路由参数

```javascript
    app.get('/find/:id/:name/:age', (req, res) => { 
        //定义路由的时候指定传递哪些参数，如果不传递参数是找不到页面的
        console.log(req.params); // {id: 123} 
    });

    请求地址和请求参数的书写，参数不再使用问号分隔开
    localhost:3000/find/123
```

### 	3.5 静态资源的处理

```javascript
    通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。

    语法：app.use(express.static('public'));//写绝对路径比较好
         app.use(('虚拟路径'),express.static('public'))可以为资源指定虚拟路径

    书写之后，public目录下的文件就可以访问了
        http://localhost:3000/images/kitten.jpg
        http://localhost:3000/css/style.css
        http://localhost:3000/js/app.js
        http://localhost:3000/images/bg.png
        http://localhost:3000/hello.html 
```

## 四、express-art-template模板引擎

### 	4.1 模板引擎

#### 		1. express-art-template

```
	为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了express-art-template。
```

#### 		2. 安装

```
	使用npm install art-template express-art-template命令进行安装
```

#### 		3. 配置模板引擎示例代码

```javascript
    // 1.当渲染后缀为art的模板时 使用express-art-template
    app.engine('art', require('express-art-template'));
         第一个参数是模板后缀，第二个是要使用的模板引擎views
    // 2.设置模板存放目录
    app.set('views', path.join(__dirname, 'views'));
          第一个参数views是配置项的名字是固定的，第二个参数是模板的位置信息,一般存放模板的的文件夹都叫views
    // 3.渲染模板时不写后缀 默认拼接art后缀
    app.set('view engine', 'art');
        设置默认模板后缀
    //4.渲染模板
    app.get('/', (req, res) => {
        // 渲染模板
        res.render('index');
        render('模板名称',{向模板中传递的数据})
            // render能做什么？ render是express提供的方法
                1. 拼接模板路径
                2. 拼接模板后缀
                3. 哪一个模板和哪一个数据进行拼接
                4. 将拼接结果响应给了客户端
    }); 
```

### 	4.2 app.locals对象

```
    将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到。
    可以将公共数据作为local对象的属性
```

```javascript
    app.locals.users = [{
         name: '张三',
         age: 20
    },{
         name: '李四',
         age: 20
    }]
```

# 博客管理系统

## 一、项目环境搭建

### 	1.1 项目介绍

```
    多人博客管理项目
    1.博客内容展示
    2.博客管理功能
```



### 	1.2 案例初始化

#### 		1. 建立项目所需文件夹

```
    public 静态资源
    model 数据库操作
    route 路由
    views 模板
```

#### 		2. 初始化项目描述文件

```
	npm init -y
```

#### 		3. 下载项目所需第三方模块

```
	npm install express mongoose art-template express-art-template
```

#### 		4.创建网站服务器

#### 		5.构建模块化路由

#### 		6.构建博客管理页面模板

```
1.模板文件中的外链资源的路径问题
	使用的是相对路径：模板文件中的相对路径，是相对于浏览器地址栏中的请求路径
	例如：如果访问的地址是locallhost/admin/login,那么外链资源的路径就是localhost/admin/lib/bootstrap....等等
	如果当客户端的请求路径和服务器端存储css文件的文件夹路径相同时，css能被正常访问到，但是如果当二者名字不同时，就不能访问了
	解决方法：把外链资源的请求地址改成绝对路径，绝对路径用/表示，代表的是服务器的绝对路径
```

## 二、项目功能实现

## 三、项目包含的知识点