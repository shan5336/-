# Vue基础

## 一、Vue概述

```
Vue：渐进式JavaScript框架
声明式渲染→组件系统→客户端路由→集中式状态管理→项目构建
官网：https://cn.vuejs.org/v2/guide/
优点：
    易用：熟悉HTML、CSS、JavaScript知识后，可快速上手Vue
    灵活：在一个库和一套完整框架之间自如伸缩
    高效：20kB运行大小，超快虚拟DOM
```

## 二、Vue基本使用

###     2.1 传统开发模式对比     

```html
原生js:
        <div id="msg"></div>
        <script type="text/javascript">
            var msg = 'Hello World';
            var div = document.getElementById('msg');
            div.innerHTML = msg;
        </script>

jQuery:
        <div id="msg"></div>
        <script type="text/javascript" src="js/jquery.js"></script>  
        <script type="text/javascript">
            var msg = 'Hello World';
            $('#msg').html(msg);
        </script>
```

### 	2.2 Vue.js之HelloWorld基本步骤

#### 		1.Vue的基本使用  

```
1.需要提供标签用于填充数据
2.引入vue.js库文件
3.可以使用vue的语法实现一些功能
4.把vue提供的数据填充到标签里面
```

#### 		2.示例

```html
<div id="app">
      <div>{{msg}}</div>
</div>

<script type="text/javascript" src="js/vue.js"></script>  
<script type="text/javascript">
     new Vue({
         el: '#app',
         data: {
            msg: 'HelloWorld'
         }
      })
</script>
```

### 	2.3 Vue.js之HelloWorld细节分析

#### 		1. 实例参数分析

```
el： 元素的挂载位置（值可以是CSS选择器或者DOM元素） 
data：模型数据（值是一个对象）
```

#### 		2.插值表达式用法 {{msg}}

```
将数据填充到HTML标签中
插值表达式支持基本的计算操作
```

#### 		3.Vue代码运行原理分析

```
概述编译过程的概念（Vue语法→原生语法）
```

## 三、Vue模板语法

###     3.1 模板语法概述

####         1. 如何理解前端渲染？

```
 把数据填充到HTML标签中
```

####         2. 前端渲染方式

#####             a.原生js拼接字符串

```html
var d = data.weather;
var info = document.getElementById('info');
info.innerHTML = '';
for(var i=0;i<d.length;i++){
     var date = d[i].date;
     var day = d[i].info.day;
     var night = d[i].info.night;
     var tag = ''; 
     tag += '<span>日期：'+date+'</sapn><ul>'; 
     tag += '<li>白天天气：'+day[1]+'</li>' 
     tag += '<li>白天温度：'+day[2]+'</li>' 
     tag += '<li>白天风向：'+day[3]+'</li>' 
     tag += '<li>白天风速：'+day[4]+'</li>'
     tag += '</ul>';
     var div = document.createElement('div');
     div.innerHTML = tag;
     info.appendChild(div);
}
缺点：不同开发人员的代码风格差别很大，随着业 务的复杂，后期的维护变得逐渐困难起来。
```

#####             b.使用前端模板引擎

```html
<script id="abc" type="text/html">
    {{if isAdmin}}
      <h1>{{title}}</h1>
       <ul>
    {{each list as value i}} 
     <li>索引 {{i + 1}} ：{{value}}</li> 
    {{/each}}
     </ul>
    {{/if}}
</script>
优点：大家都遵循同样的规则写代码，代码可读性 明显提高了，方便后期的维护。 
缺点：没有专门提供事件机制。
```

#####             c.使用vue特有的模板语法

```
1.差值表达式
2.指令 
3.事件绑定
4.属性绑定
5.样式绑定
6.分支循环结构
```

### 3.2 指令

####     1.什么是指令？

```
  什么是自定义属性
  指令的本质就是自定义属性
  指令的格式：以v-开始（比如：v-cloak）
```

####     2.v-cloak指令用法

```
插值表达式存在的问题：“闪动” 
如何解决该问题：使用v-cloak指令
解决该问题的原理：先隐藏，替换好值之后再显示最终的值
```

#####         v-cloak指令的用法

```html
1.提供样式
    [v-cloak]{
           display:none;
    }

2.在插值表达式所在的标签中添加v-cloak指令
    <div v-cloak>
         {{ message }}
    </div>

3.原理：
	先通过样式隐藏内容，在内存中进行值的替换，替换好之后再显示最终的结果
```

#### 3.数据绑定指令(响应式的)

##### 	1.v-text  填充纯文本

```html
<span v-text="msg"></span>
<span>{{msg}}</span> 
① 相比插值表达式更加简洁  
```

##### 	2.v-html  填充HTML片段 

```
<div v-html="html"></div>//填充的是html片段
① 存在安全问题 
② 本网站内部数据可以使用，来自第三方的数据不可以用 
```

##### 	3.v-pre  填充原始信息

```
① 显示原始信息，跳过编译过程（分析编译过程）
```

##### 	4.示例：

```html
<body>
    <div id="app" v-cloak>
         <div>{{msg}}</div>
         <div v-text='msg'></div>//hello vue
         <div v-html='msg1'></div>//一级标题html
         <div v-pre>{{msg}}</div>//{{msg}}
    </div>
    <script src="js/vue.js"></script>
         <script>
              /* 
               v-text指令的用法
               <div v-text='msg'></div>
              */
               var vm=new Vue({
                   el:'#app',
                   data:{
                       msg:'hello vue',
                       msg1:'<h1>HTML</h1>'
                    }
                })
          </script>
</body>
```

####     4.数据响应式

##### 		1.如何理解响应式

```
① html5中的响应式（屏幕尺寸的变化导致样式的变化）
② 数据的响应式（数据的变化导致页面内容的变化）
```

##### 		2.什么是数据绑定

```
① 数据绑定：将数据填充到标签中 
```

##### 		3.v-once只编译一次

```
① 显示内容之后不再具有响应式功能
```

### 3.3 双向数据绑定

####     1.什么是双向数据绑定？

```
体现在数据到页面和页面到数据
比如：用户在表单里面输入内容的时候会影响数据的变化
```

####     2.双向数据绑定分析 

```html
v-model指令:在表单控件或者组件上创建双向绑定
用法：
    <input type='text' v-model='uname'/>
```

#### 	3.MVVM设计思想 

```
M(model) 
    模型，其实就是我们用到的数据，data中的数据，提供数据
V(view)  
    模板，本质上就是DOM元素，提供页面展示效果
VM(View-Model)
    把两者结合到一起
    
DOM-->DOM Listeners 事件监听-->Model
Model-->Data Bindings 数据绑定 -->DOM
```

### 3.4 事件绑定

#### 	1. Vue如何处理事件？ 

##### 			a. v-on指令用法

```html
<input type='button' v-on:click='num++'/>
```

##### 			b. v-on简写形式

```html
<input type='button'@click='num++'/>
```

#### 	2. 事件函数的调用方式 

##### 		a. 直接绑定函数名称

```html
 <button v-on:click='handle'>Hello</button> 
```

##### 		b. 调用函数 

```html
<button v-on:click='handle()'>Say hi</button> 
var vm=new Vue({
     el:'#app',
     data:{
         num: 0,
     },
     methods: {//事件处理函数
         handle:function(){
             this.num++;//这个this指向的是Vue的实例vm
         }  
     },
})
```

#### 	3. 事件函数参数传递 

```html
普通参数和事件对象
<button v-on:click='say(参数,$event)'>Say hi</button>
<button v-on:click='say'>Say hi</button>
$event：传递事件对象，固定名字，只有使用这中调用函数的方式才需要传递，如果是使用直接绑定函数名称是默认携带了事件对象
```

####     4. 事件修饰符

```html
a .stop 阻止冒泡
   <a v-on:click.stop="handle">跳转</a> 
   event.stopPropagation();//传统方式阻止冒泡
   
b .prevent 阻止默认行为
   <a v-on:click.prevent="handle">跳转</a> 
   event.preventDefault();//传统方式阻止默认事件
```

#### 	5. 按键修饰符

##### 		.enter 回车键

```html
<input v-on:keyup.enter='submit'>
```

#####  		.delete

```html
 <input v-on:keyup.delete='handle'> 
```

#####  		.esc 退出键 

```html
 <input v-on:keyup.esc='handle'> 
```

####     6.自定义按键修饰符

```html
全局 config.keyCodes 对象
定义:
Vue.config.keyCodes.f1 = 112
使用：
<input type="text" v-on:keyup.f1='handle' v-model='info'>
含义：只有在按keyCode为112的按键弹起时才会触发handle这个事件对象
```

### 3.5 属性绑定

#### 	1.Vue如何动态处理属性？ 

##### 		a.v-bind指令用法

```html
 <a v-bind:href='url'>跳转</a> 
```

##### 		b.缩写形式 

```html
<a :href='url'>跳转</a>
```

#### 2.v-model的底层实现原理分析

```html
使用属性绑定和事件绑定来实现数据的双向绑定
<input v-bind:value="msg" v-on:input="msg=$event.target.value">//简写版

例：实现v-model的功能
 <input type="text" v-bind:value="msg" v-on:input="handle" >//修改表单的值触发input事件
 methods: {
    handle:function(event){
        this.msg=event.target.value;//用输入域中的最新数据覆盖原来的数据
    }
}

//实现的功能是一样的
<input type="text" v-bind:value="msg" v-on:input="handle" >
<input type="text" v-bind:value="msg" v-on:input="msg=$event.target.value" >
<input type="text" v-model="msg">
```

### 3.6 样式绑定

#### 	1.class样式处理 v-bind:class=...

##### 		a.对象语法 

```html
 <div v-bind:class="{ active: isActive, error: isError}"></div> 

 //第一个是类名，第二个是控制是否显示,多个类名用逗号分隔开
 data:{
    isActive:true//这是一个标志位，为true,默认是显示的
    isError:true
 }

//
<style>
    .active {
        ...
    }
    .error {
        ...
    }
</style>
```

##### 		b.数组语法

```html
<div v-bind:class="[activeClass, errorClass]"></div>//直接添加类名

 data:{
    activeClass:'active',
    errorClass:'error'
 },
 methods: {
    handle:function(){
        this.activeClass='';//点击按钮使样式为空则样式没有了，如果想要回到之前的样式只能给样式重新赋值
    }
 }
```

##### 		c.样式绑定相关语法细节

###### 			1.对象绑定和数组绑定可以结合使用

```html
<div v-bind:class='[activeClass,errorClass,{test:isTest}]'>测试样式</div>

data:{
    activeClass:'active',
    errorClass:'error',
    isTest:'true'
}
```

###### 		 2.class绑定的值可以简化操作

```html
数组用法：
<div v-bind:class='arrClasses'></div>
data:{
   activeClass:'active',
   errorClass:'error',
   isTest:'true',
   arrClasses:['active','error']//这种用法如果想要去除或者增加就需要对数组进行操作
}
```

```html
对象用法：
<div v-bind:class='objClasses'>第二个测试样式</div>
data:{
   objClasses:{//这种用法可以在methods当中添加方法来进行操作
        active:true,
        error:true
   }
}
```

######  		3.默认的class如何处理

```html
<div class="base" v-bind:class='objClasses'>默认样式</div>
//默认的样式会被保留   
```

#### 2. style样式处理

##### a. 对象语法 

###### 普通写法：

```html
<div v-bind:style='{ border: borderStyle, width: widthStyle, height: heightStyle}'></div>
//标准的属性名：属性样式


data: {
   borderStyle:'1px solid red',
   widthStyle:'200px',
   heightStyle:'100px',
}
```

###### 简化写法

```html
<div v-bind:style='objStyle'></div>

data: {
   objStyle:{
       border:'1px solid blue',
       width:'200px',
       height:'200px'
   }
}
```

##### b.数组语法

```html
<div v-bind:style='[objStyle,overrideStyle]'></div>
//如果两个样式之间有相同的属性，则后面的属性会覆盖原来的，其他的属性叠加在一起
data: {
   objStyle:{
        border:'1px solid blue',
        width:'200px',
        height:'200px'
   },
   overrideStyle:{
        border:'5px solid yellow',
        backgroundColor:'blue'
   }
}
```

###   3.7 分支循环结构

#### 	1. 分支结构

```
v-if  
v-else  
v-else-if  
v-show：其实就是display,控制元素是否显示
```

#####      示例代码:

```html
a.
<div v-if='score>=90'>优秀</div>
<div v-else-if='score<90&&score>=90'>良好</div>
<div v-else-if='score<80&&score>60'>一般</div>
<div v-else=>比较差</div>

b.
data: {
    score:91//渲染出优秀这个div，虽然上面有四个div但是根据条件来进行判断，最后指回渲染出符合条件的div，在页面的代码中是不会看见其他没有被渲染的div
}

c.v-show
<div v-show='flag'>测试v-show</div>
data: {
    flag:false
}
//页面中会渲染出这个div,就是页面代码中能找到这个div,但是不会显示，是display:none
```

#### 2. v-if与v-show的区别 

```
v-if控制元素是否渲染到页面 
v-show控制元素是否显示（已经渲染到了页面）
```

#### 3.循环结构(遍历数组)

```html
 a.v-for遍历数组
   <ul>
      <li v-for='item in fruits'>{{item}}</li>
      //这个item是自定义的名字，代表的意思就是fruits的其中一项，in是关键字，fruits是要遍历的那个数组
   </ul>
	含有索引号的遍历：
   <li v-for='(item,index) in list'>{{item}} + '---' +{{index}}</li>//index是索引号
   
b.key的作用：帮助Vue区分不同的元素，从而提高性能
  key的值是唯一的，作为唯一的标识，如果数据本身没有id,可以使用index代替
  <li :key='item.id' v-for='(item,index) in list'>{{item}} + '---' {{index}}</li>
```

#### 4.循环结构(遍历对象)

```html
a.v-for遍历对象
   <div v-for='(value, key, index) in object'></div>
   
b.v-if和v-for结合使用
   <div v-if='value==12' v-for='(value, key, index) in object'></div>
```

## 四、基础案例

###     Tab选项卡

####     实现步骤：

```
1. 实现静态UI效果
	用传统的方式实现标签结构和样式
2. 基于数据重构UI效果
	将静态的结构和样式重构为基于Vue模板语法的形式 
	处理事件绑定和js控制逻辑
3.声明式编程
	模板的结构和最终显示的效果基本一致
```

## 五、Vue常用特性

###     5.1 常用特性概览

```
表单操作
自定义指令
计算属性
侦听器
过滤器
生命周期
```

### 	5.2 表单操作

#### 		1.基于Vue的表单操作 

```
input  单行文本 
textarea  多行文本 
select  下拉多选 
radio  单选框 
checkbox  多选框
```

#### 	3.表单域修饰符 

```
number：
<input v-model.number="age" type="number">
      trim：去掉开始和结尾的空格 
      lazy : 将input事件切换为change事件
input事件是在每次输入的时候都会触发，而change事件只有当失去焦点的时候才会触发
用途：比如注册的时候，输入用户名后失去焦点会验证有没有注册过
<input v-model.lazy="name" >
```

### 5.3 自定义指令

#### 	1. 为何需要自定义指令？

内置指令不满足需求

#### 	2. 自定义指令的语法规则（获取元素焦点）

```
Vue.directive('focus' {
    inserted: function(el) { //钩子函数，参考使用文档
     // inserted是固定写法,被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
     // el指的是指令所绑定的元素
     el.focus();// 获取元素的焦点 el.focus();
    }
}) 
```

#### 	3. 自定义指令用法

```
<input type="text" v-focus>
```

#### 	4. 带参数的自定义指令（改变元素背景色）

```
全局指令
<input type="text" v-color="msg">
Vue.directive('color', {
    bind: function(el, binding) {
         el.style.backgroundColor = binding.value.color;
         console.log(binding);//通过bind函数的binding参数中的value可以拿到msg的值
         console.log(binding.value);
    }
})

data: {
    msg:{
		color:'orange'
    }
}
```

####     5.局部指令

```
添加到vue实例化对象里面的，也就是和data,methods并列的那里，局部指令只能在本组件中使用
directives: {
    focus: { // 指令的定义
 inserted: function (el) {
     el.focus()
 }
    }
} 
```



### 5.4 计算属性

#### 1.为何需要计算属性？

表达式的计算逻辑可能会比较复杂，使用计算属性可以使模板内容更加简洁

#### 2.计算属性的用法

```
computed: {
    reversedMessage: function () {
 		return this.msg.split('').reverse().join('')//把计算的公式写到这里，并且return
    }
}
使用：
<div>{{reversedMessage}}</div>不需要调用（）
```

#### 3.计算属性与方法的区别 

```
a.计算属性是基于它们的依赖(比如这里的data中的msg数据)进行缓存的 
    <div>{{reversedMessage}}</div>
    <div>{{reversedMessage}}</div>
    
    computed: {
         reversedMessage: function () {
            console.log(123);
            //上面使用了两次，但是打印的时候只会打印一次，因为上一次已经有下面那个结果了，会放在缓存中，再次调用的时候就会使用第一次计算的结果，不会重新执行，如果他们的依赖，也就是使用的数据发生了改变就会重新执行
            return this.msg.split('').reverse().join('')//把计算的公式写到这里，并且return
         }
    }

b.方法不存在缓存
	每一次都会重新执行
```

### 5.5 侦听器

#### 1.侦听器的应用场景

数据变化时执行异步或开销较大的操作

#### 2.侦听器的用法

```html
data: {
    firstName: 'Jim',
    lastName: 'Green',
    fullName:'Jim Green'
},
watch: {
    firstName: function(val){
 // val表示变化之后的值
 this.fullName = val + this.lastName;
    },
    lastName: function(val) {
 this.fullName = this.firstName + val;
    }
}
```

####     3.案例：

```html
<body>
    <div id="app">
       <div>
          <span>用户名：</span>
          <span>
          	<input type="text" v-model.lazy='uname'>
          </span>
          <span>{{tip}}</span>
       </div>
     </div>
     <script type="text/javascript" src="js/vue.js"></script>
     <script type="text/javascript">
                    /*      
                侦听器
                1、采用侦听器监听用户名的变化
                2、调用后台接口进行验证
                3、根据验证的结果调整提示信息
                */
         var vm = new Vue({
              el: '#app',
              data: {
                  uname:'',
                  tip:'' 
              },
              methods: {
                  checkName:function(uname){
                   //调用接口，可以定时任务的方式模拟接口调用
                   var that=this;//定时器下的this指向的是window
                   setTimeout(function(){
                        if(uname=='admin'){
                               that.tip='用户名已经存在'
                         }else{
                               that.tip='验证成功'
                         }
                    },2000)
                 }
               },
              watch: {
                 uname:function(val){
                      //调用后台接口验证
                      this.checkName(val);
                      //修改提示信息
                      this.tip='正在验证...';
      			 }
      		 }
     	});
    </script>
</body>
```



### 5.6 过滤器

#### 1.过滤器的作用是什么？

```
格式化数据，比如将字符串格式化为首字母大写，将日期格式化为指定的格式等
```

#### 2.自定义过滤器

```html
Vue.filter(‘过滤器名称’, function(value){ 
    // 过滤器业务逻辑 
})
例：
  Vue.filter('upper',function(val){//接收一个参数，代表要处理的参数
      return val.charAt(0).toUpperCase()+val.slice(1);//将首字母变成大写
  })
```

#### 3.过滤器的使用

```html
<div>{{msg | upper}}</div> //先变成大写
<div>{{msg | upper | lower}}</div>  //先变成大写再变成小写，级联调用
<div v-bind:id=“id | formatId"></div> 
```

#### 4.局部过滤器

```html
filters:{
    upper(过滤器的名称): function(){//处理函数
 return val.charAt(0).toUpperCase()+val.slice(1);
    }
} 
```

#### 5.带参数的过滤器

```html
Vue.filter(‘format’, function(value, arg1){ 
    // value就是过滤器传递过来的参数 
})
Vue.filter(‘format’, function(value, arg1){ 
    // value就是过滤器传递过来的参数 
})
```

####     6.过滤器的使用

```
<div>{{date | format(‘yyyy-MM-dd')}}</div> 
```

### 5.7 生命周期

#### 1.主要阶段

```
a.挂载（初始化相关属性） 
    ① beforeCreate 
    ② created 
    ③ beforeMount 
    ④ mounted 
        //mounted触发之后代表初始化完成，模板中的内容已经存在了，可以用来调用后台数据的判断
b.更新（元素或组件的变更操作） 
    ① beforeUpdate 
    ② updated 
c.销毁（销毁相关属性） 
    ① beforeDestroy 
    ② destroyed
```

#### 2.Vue实例的产生过程

```
① beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用。 
② created 在实例创建完成后被立即调用。 
③ beforeMount在挂载开始之前被调用。 
④ mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。 
⑤ beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。 
⑥ updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 
⑦ beforeDestroy 实例销毁之前调用。 ⑧ destroyed 实例销毁后调用。
```

## 六、综合案例

###     图书管理

####     6.1 知识点

#####         1.数组更新检测     

```
变更方法(变异方法)：触发视图更新，会更新数据，影响原始数组
    push()
    pop()
    shift()
    unshift()
    splice(index,n):删除索引为index的数据，删除n个
    sort()
    reverse()
替换数组：返回一个新的数组，不会影响原始的数据
    filter()
    concat() 
    slice()
```

##### 3.修改响应式数据 

```
Vue.set(vm.items, indexOfItem, newValue) 
vm.$set(vm.items, indexOfItem, newValue) 
效果是一样的，在语法上有一些差异
① 参数一表示要处理的数组名称 
② 参数二表示要处理的数组的索引 
③ 参数三表示要处理的数组的值
④ 除了数组外也可以处理对象的属性vm.$set(vm.obj, 属性名, 属性值) 

例：
    var vm = new Vue({
        el: '#app',
        data: {
            list: ['apple', 'orange', 'banana'],
            info: {
                name: 'lisi',
                age: 12
            ,}
        },
    });
    vm.list[1] = 'lemon';//通过这种形式修改的不是响应式的,页面还是显 'apple', 'orange', 'banana'
    Vue.set(vm.list, 2, 'lemon');
    vm.$set(vm.list, 1, 'lemon');
```

# Vue组件化开发

## 一、组件化开发思想

###     1.1 现实中的组件化思想体现

​        标准、分治、重用、组合

###     1.2 编程中的组件化思想体现

###     1.3 组件化规范: Web Components

```
还未被浏览器广泛支持
	要求：
        我们希望尽可能多的重用代码
        自定义组件的方式不太容易（html、css和js）
        多次使用组件可能导致冲突
        Web Components 通过创建封装好功能的定制元素(自定义标签)解决上述问题
        官网：https://developer.mozilla.org/zh-CN/docs/Web/Web_Components
        Vue实现了上述功能的一部分
```

## 二、Vue组件注册

###     2.1 全局组件注册语法

####         基础语法：

```html
 Vue.component(组件名称, { 
      data: 组件数据, 
      template: 组件模板内容 
 })
```

####         案例：

```html
注册一个名为 button-counter 的新组件，语法与实例化Vue对象有些相似，其实Vue实例在本质上也是一个组件
Vue.component('button-counter',{
     //数据
     data:function(){
         return {
              count:0
         }
      },
      //模板
      //template:'<button @click="count++">点击了{{count++}}次</button>',//也可以通过methods来调用
      template:'<button @click="handle">点击了{{count}}次</button>',
      // 方法
      methods:{
          handle:function(){
               this.count++;
          }
      }
})
```

### 2.2 组件用法

#### 基本使用：

```html
<div id="app">
    <button-counter></button-counter>
</div>
```

#### 重用：        

```html
多个组件之间的数据是独立的
<div id="app">
    <button-counter></button-counter>
    <button-counter></button-counter>
    <button-counter></button-counter>
</div>
```

###     2.3 组件的注意事项

####         1.data必须是一个函数 

```html
  分析函数与普通对象的对比
  例：
     data:function(){
         return {
              count:0
         }
     }
     如果换成对象形式：
     data:{
         count:0
     }
     控制台会报错，希望data是一个函数，并且返回某一个值，使用函数的形式会形成一个闭包的环境，也就是让每一个组件都拥有一份自己独立的数据
```

####         2.组件模板内容必须是单个根元素      

```html
分析演示实际的效果
  正确：
     template:'<button @click="handle">点击了{{count}}次</button>'
  错误：
     template:'<button @click="handle">点击了{{count}}次</button><button>测试</button>'
     会出现报错，因为只能拥有一个根元素，这两个button 是兄弟关系
  修改：
     template:'<div><button @click="handle">点击了{{count}}次</button><button>测试</button></div>'
     template:'<div><button @click="handle">点击了{{count}}次</button><button @click="handle">点击了{{count}}次</button></div>',//用了同一个count,两个数据一起变化
```

####         3.组件模板内容可以是模板字符串 

```
模板字符串需要浏览器提供支持（ES6语法，考虑兼容性）
//使用模板字符串的方法，代码可读性会更高
template: `
    <div>
        <button @click="handle">点击了{{count}}次</button>
        <button @click="handle">点击了{{count}}次</button>
    </div>
`,
```

####  	4.组件命名方式 

```
a.短横线方式
    Vue.component('button-counter', { /* ... */ })
b.驼峰方式
    Vue.component('HelloWorld', { /* ... */ })
    使用组件：
    字符串模板中：可以使用驼峰的方式
        template: `
        <div>
            <button @click="handle">点击了{{count}}次</button>
            <button @click="handle">点击了{{count}}次</button>
            <HelloWorld></HelloWorld>
        </div>
        `
    在普通的标签模板中使用：必须使用短横线的方式
        <hello-world></hello-world>
        转换规则：首字母变成小写，中间加上短横线
```

###     2.4 局部组件注册

```
 var ComponentA = { /* ... */ }
        var ComponentB = { /* ... */ }
        var ComponentC = { /* ... */ }
        new Vue({
            el: '#app'
            components: {
                'component-a': ComponentA,组件名称：组件内容
                'component-b': ComponentB,
                'component-c': ComponentC,
            }
        })   
```

```html
例：局部组件只能在注册它的父组件中使用，比如这里只能在#app中使用，如果另外定义了一个全局组件，然后想要在这个全局组件中使用局部组件时不可以的，同理，自定义指令和过滤器中的局部自定义指令和局部过滤器也是同样的道理

<div id="app">
     <hello-world></hello-world>
     <hello-tom></hello-tom>
     <hello-jerry></hello-jerry>
</div>

var HelloWorld={
	data:function(){
        return {
            msg:'hello world'
        }
	},
template:'<div>{{msg}}</div>'
};

var HelloTom={
    data:function(){
        return {
        	msg:'hello Tom'
        }
    }
},
template:'<div>{{msg}}</div>'
};

var HelloJerry={
    data:function(){
         return {
         	msg:'hello Jerry'
         }
    }
},
template:'<div>{{msg}}</div>'
};

var vm=new Vue({
    el:'#app',
    components:{
        'hello-world':HelloWorld,
        'hello-tom':HelloTom,
        'hello-jerry':HelloJerry
    }
})
```




## 三、Vue调试工具用法

###     3.1 调试工具安装

```
① 克隆仓库 
② 安装依赖包 
③ 构建 
④ 打开Chrome扩展页面 
⑤ 选中开发者模式 
⑥ 加载已解压的扩展，选择shells/chrome
```

###     3.2 调试工具用法

## 四、组件间数据交互

###     4.1 父组件向子组件传值

#### 		1.组件内部通过props接收传递过来的值

```html
Vue.component(‘menu-item', {
    props: ['title'],
    template: '<div>{{ title }}</div>'
})
```

####         2.父组件通过属性将值传递给子组件

```
<menu-item title="来自父组件的数据"></menu-item> 
<menu-item :title="title"></menu-item>
```

####         3.示例：

```html
<body>
    <div id="app">
        {{pmsg}}
        <menu-item title='来自父组件的值'></menu-item>  静态传值
        <menu-item :title='ptitle' content='hello'></menu-item>  动态传值+动态传值
        //打印以下内容
        父组件中的内容
        子组件的内容..............来自父组件的值..............undefined（因为前面那个没有定义）
        子组件的内容..............动态绑定属性..............hello
    </div>
    <script src="js/vue.js"></script>
    <script>
        Vue.component('menu-item',{
            props:['title','content'],//接收父组件的信息，是上面自组件添加的属性
            data:function(){
                return {
                    msg:'子组件的内容'
                }
            },
            template:'<div>{{msg+".............."+title+".............."+content}}</div>'
            //这个title和content是从props中取过来的
        })
        var vm=new Vue({
            el:'#app',
            data:{
                pmsg:'父组件中的内容',
                ptitle:'动态绑定属性'
            }
        })
    </script>
</body>
```

####         4.props属性名规则

```html
a.在props中使用驼峰形式，模板中需要使用短横线的形式
    Vue.component(‘menu-item', { 
        // 在 JavaScript 中是驼峰式的 
        props: [‘menuTitle'],
        template: '<div>{{ menuTitle }}</div>'
    }) 
    <!– 在html中是短横线方式的 --> 
    <menu-item menu-title=“nihao"></menu-item>
b.字符串形式的模板中没有这个限制
    Vue.component('menu-item',{
        props:['menuTitle'],//接收父组件的信息
        data:function(){
            return {
                msg:'子组件的内容'
            }
        },
        template:'<div>{{menuTitle}}<third-com testTitle="hello"></third-com></div>'
        //这种情况下使用驼峰是合法的
    })
```

####         5.props属性值类型

```
字符串 String 
数值 Number 
布尔值 Boolean 
数组 Array
对象 Object
```

###     4.2 子组件向父组件传值

```
  props是单向数据流的，就是只希望从父组件向子组件传递值，虽然它没有禁止我们从子组件向父组件传递值，但是我们不建议这么双向传递，因为这会使数据的逻辑变得非常复杂，因此定义的相应地从子组件向父组件传值的方式
```

####         1.子组件通过自定义事件向父组件传递信息

```html
 <button v-on:click='$emit("enlarge-text") '>扩大字体</button>
$emit是固定的写法，用于触发自定义事件，这个方法接收第一个参数就是事件名称，事件名称是自己定义的
```

####         2.父组件监听子组件的事件

```html
<menu-item v-on:enlarge-text='fontSize += 0.1'></menu-item>
 这里的enlarge-text要与上面的自定义事件保持一致
 绑定的事件也可以封装一下,handle定义在methods中
<menu-item v-on:enlarge-text='handle'></menu-item>
```

####         3.子组件通过自定义事件向父组件传递信息

```html
<button v-on:click='$emit("enlarge-text", 0.1) '>扩大字体</button>
自定义事件的第二个参数是子组件要向父组件传递的值，也就是这里的0.1
```

####         4.父组件监听子组件的事件

```html
<menu-item v-on:enlarge-text='fontSize += $event'></menu-item>
<menu-item @enlarge-text='handle($event)'></menu-item>
$event是接收到的子组件传递过来的参数，固定写法
```

###     4.3 非父子组件间传值

####         1.单独的事件中心管理组件间的通信

```
var eventHub = new Vue();
eventHub是事件中心
```

####         2.监听事件与销毁事件

```
eventHub.$on('add-todo', addTodo)
    $on用于监听事件，第一个参数是事件名称，第二个参数是事件函数
eventHub.$off('add-todo')
    $off用于销毁事件，参数是事件名称
```

####         3.触发事件

```
eventHub.$emit(‘add-todo', id)
```

####         例：

```
<body>
    <div id="app">
        <div>父组件</div>
        <div>
            <button @click='handle'>销毁</button>
        </div>
        <test-tom></test-tom>
        <test-jerry></test-jerry>
    </div>
    <script src="js/vue.js"></script>
    <script>
        // 内容描述，两个按钮，点击tom的按钮，jerry加2，点击jerry的按钮，tom
        //提供事件中心
        var hub=new Vue();

        Vue.component('test-tom',{
            data:function(){
                return {
                    num:0
                }
            },
            template:`
                <div>
                    <div>TOM:{{num}}</div>
                    <div>
                        <button @click='handle'>点击</button>
                    </div>
                </div>
            `,
            methods: {
                handle:function(){
                    //按钮点击之后，触发了对方监听的那个事件(jerry-event)，并且像对方传递一个数值
                    通过hub.$emit来触发
                    hub.$emit('jerry-event',1)
                }
            },
            mounted:function(){  //当模板加载完毕，开始进行事件的监听
                //监听事件
                hub.$on('tom-event',(val)=>{
                    //监听'tom-event'这个事件，val是对方(兄弟组件)传递过来的数据
                    this.num+=val;
                })
            }
        });
        Vue.component('test-jerry',{
            data:function(){
                return {
                    num:0
                }
            },
            template:`
                <div>
                    <div>JERRY:{{num}}</div>
                    <div>
                        <button @click='handle'>点击</button>
                    </div>
                </div>
            `,
            methods: {
                handle:function(){
                    //触发兄弟组件的事件
                    hub.$emit('tom-event',2)
                }
            },
            mounted:function(){
                hub.$on('jerry-event',(val)=>{
                    this.num+=val;
                })
            }
        })

        var vm=new Vue({
            el:'#app',
            data:{
            
            },
            methods:{
                handle:function(){
                    hub.$off('tom-event');
                    hub.$off('jerry-event');
                }
            }
        })
    </script>
</body>
```

## 五、组件插槽

###     5.1 组件插槽的作用    

```
父组件向子组件传递内容(模板内容)
父：<alert-box>hi</alert-box>  --------------------->  子：<slot></slot>
模板内容是hi,这个内容会通过插槽的方式传递给子组件，子组件的模板中会预留一个位置(这个位置就是插槽)用来放置这个数据
```

###     5.2 组件插槽基本用法

####         1.插槽位置

```html
Vue.component('alert-box', {
      template: `
          <div class="demo-alert-box">
                <strong>Error!</strong>
                <slot></slot>// 插槽位于子组件模板中，<slot></slot>是固定的
          </div>
      `
})
完整呈现的内容是：Error! Something bad happened
```

####         2.插槽内容

```
<alert-box>Something bad happened.</alert-box>
```

####         3.基本用法： 

```html
<body>
    <div id="app">
        <alert-box>有bug发生</alert-box>
        <alert-box>有一个警告</alert-box>
        <alert-box></alert-box>
    </div>
    <script src="js/vue.js"></script>
    <script>
        Vue.component('alert-box', {
            template: `
                <div>
                    <strong>ERROR:</strong>
                    <slot>默认内容</slot>//如果传递了内容，默认内容会被覆盖
                </div>
            `
        });
        var vm = new Vue({
                        el: '#app',
                        data: {

                        }
        })
    </script>
</body>
显示内容：
ERROR: 有bug发生
ERROR: 有一个警告
ERROR: 默认内容
```

### 5.3 具名插槽用法(有名字的插槽name)

####     1.插槽定义

```html
<div class="container">
    <header>
         <slot name="header"></slot>
    </header>
    <main>
         <slot></slot>
    </main>
    <footer>
         <slot name="footer"></slot>
    </footer>
</div> 
```

####     2.插槽内容

```html
<base-layout> 
     <h1 slot="header">标题内容</h1> //匹配到了上面的name为header的插槽

      <p>主要内容1</p> //没有名字，就填到没有名字的默认的插槽中
      <p>主要内容2</p>

      <p slot="footer">底部内容</p> 
</base-layout>

另外一种内容填充方式
<base-layout>
      <template slot='header'>
           <!-- template的作用：临时性的包裹内容，但是不会渲染到页面上，并且里面的内容都匹配header -->
           <p>标题信息1</p>
           <p>标题信息2</p>
      </template>
           <p>主要内容1</p>
           <p>主要内容2</p>
      <template slot='footer'>
            <p>底部信息信息1</p>
            <p>底部信息信息2</p>
      </template>
</base-layout>
```

### 5.4 作用域插槽

​    应用场景：父组件对子组件的内容进行加工处理

####     1.插槽定义   

```
这个是子组件的模板中
<ul>
    <li v-for= "item in list" v-bind:key= "item.id" >
         <slot v-bind:info="item">
            //绑定一个属性info,这个名字是自定义的，用来提供给父组件，是它的值“item”是上面那个item
            {{item.name}}
         </slot>
     </li>
</ul>
```

####     2.插槽内容

```html
 <fruit-list v-bind:list= "list">
     <template slot-scope="slotProps">
      //template标签中的slot-scopes属性可以得到子组件中绑定的属性，也就是上面那个info,后面那个slotProps是自定义的名称
           <strong v-if="slotProps.item.current">//给每一个项添加样式
                {{ slotProps.info.name }}//具体水果的名称
           </strong>
     </template>
</fruit-list>
```

####     3.示例代码：

```html
<body>
    <div id="app">
        <fruit-list :list='list'>
        <template slot-scope='slotProps'>
            <strong v-if='slotProps.info.id==3' class="current">//id为3的那一项添加样式其余的放在span中
                {{slotProps.info.name}}
            </strong>
            <span v-else>{{slotProps.info.name}}</span>
        </template>
        </fruit-list>
    </div>
    <script type="text/javascript" src="js/vue.js"></script>
    <script type="text/javascript">
        /*
        作用域插槽
        */
        Vue.component('fruit-list', {
        props: ['list'],
        template: `
            <div>
            <li :key='item.id' v-for='item in list'>
                <slot :info='item'>{{item.name}}</slot>
            </li>
            </div>
        `
        });
        var vm = new Vue({
        el: '#app',
        data: {
            list: [{
            id: 1,
            name: 'apple'
            },{
            id: 2,
            name: 'orange'
            },{
            id: 3,
            name: 'banana'
            }]
        }
        });
    </script>
</body>
```

## 六、基于组件的案例

# Vue前后端交互

## 一、前后端交互模式

###     1.1 接口调用方式

```
    1.原生ajax 
    2.基于jQuery的ajax 
    3.fetch 
    4.axios 
```

###     1.2 URL地址格式

####         1.传统url

```
    格式：schema://host:port/path?query#fragment
     schema:协议，必选
     host:域名或者IP地址，必选
     port:端口，http默认端口80，必选，但是可以省略
     path:路径，用于区分不同资源，可选
     query:查询参数，可选
     fragment:锚点(哈希Hash),用于定位页面的某个位置，可选
```

####         2.Restful形式的URL

```
    HTTP请求方式
    GET 请求
    POST 添加
    PUT 修改
    DELETE删除
```

## 二、Promise用法

###     2.1 异步调用

####         1.异步效果分析

```
     a.定时任务
     b.Ajax
     c.事件函数
```

####         2.多次异步调用的依赖分析

```javascript
   a.多次异步调用的结果顺序不确定 
   b.异步调用结果如果存在依赖需要嵌套
       例：回调地狱
                $.ajax({
                    url: 'http://localhost:3000/data',
                    success: function (data) {
                        console.log(data)
                        $.ajax({
                            url: 'http://localhost:3000/data1',
                            success: function (data) {
                                console.log(data)
                                $.ajax({
                                    url: 'http://localhost:3000/data2',
                                    success: function (data) {
                                        console.log(data)
                                    }
                                });
                            }
                        });
                    }
                });
```

###     2.2 Promise概述

```
    Promise是异步编程的一种解决方案，从语法上讲，Promise是一个对象(也是一个函数typeof Promise是function，但是函数本质上也是一个对象)，从他可以获取异步操作的消息
    使用Promise的好处：
       主要解决异步深层嵌套的问题（回调地狱） 
       promise 提供了简洁的API 使得异步操作更加容易
```

###     2.3 promise基本用法

```javascript
    a.实例化Promise对象，构造函数中传递函数，该函数中用于处理异步任务
    b.resolve和reject两个参数用于处理成功和失败两种情况，并通过p.then获取处理结果
    c.示例：
       var p=new Promise(function(resolve,reject){
           //这个函数用于实现异步任务
           setTimeout(function(){
                var flag=false;
                if(flag){
                     resolve('正确的');//成功的时候调用resolve函数，并传递相应信息
                }else{
                     reject('错误的')//失败的时候调用reject
                }
            },1000)
        });
        //p.then接收结果
        p.then(function(data){
             console.log(data)//成功时候的函数，data是成功的时候传递的数据
        },function(info){
             console.log(info)//失败时候的函数，info是传递过来的数据
        })
```

###     2.4 基于Promise处理Ajax请求

####         1.处理原生Ajax

```javascript
      function queryData(url){
          var p=new Promise(function(resolve,reject){
              var xhr=new XMLHttpRequest();
              xhr.onreadystatechange=function(){
                    //当ajax状态码readyState发生变化的时候会触发onreadystatechange事件
                   if(xhr.readyState!=4) return;
                   if(xhr.readyState==4&&xhr.status==200){
                    //处理正常的情况
                        resolve(xhr.responseText);
                    }else{
                        reject('服务器错误')
                    }
               }
               xhr.open('get',url);
               xhr.send(null);
           });
           return p;
     }
     queryData('http://localhost:3000/data')
           .then(function(data){
                 console.log(data);
            },function(info){
                 console.log(info)
            })
```

####         2.发送多次ajax请求

```javascript
 queryData('http://localhost:3000/data')
            .then(function(data){
                console.log(data);
                return queryData('http://localhost:3000/data1')
                //返回一个新的Promise实例对象
            })
            .then(function(data){
                console.log(data);
                return queryData('http://localhost:3000/data2')
            })
            .then(function(data){
                console.log(data)
            })
            //可以按照调用顺序输出
```

###     2.5 then参数中的函数返回值

####         1.返回Promise实例对象

```javascript
 返回的该实例对象会调用下一个then
            例：
            queryData('http://localhost:3000/data')
                .then(function(data){
                    console.log(data);
                    return queryData('http://localhost:3000/data1')
                })
                .then(function(data){
                    console.log(data);
                    return new Promise(function(resolve,reject){
                        setTimeout(function(){
                            resolve(123);
                        },1000)
                    })
                })
                .then(function(data){//data是上面那个Promise对象传递的值，也就是123
                    console.log(data)
                })
```

####         2.返回普通值

```javascript
  返回的普通值会直接传递给下一个then,通过参数中函数的参数接收该值
            例：
            queryData('http://localhost:3000/data')
                .then(function(data){
                    console.log(data);
                    return queryData('http://localhost:3000/data1')
                })
                .then(function(data){
                    console.log(data);
                    return new Promise(function(resolve,reject){
                        setTimeout(function(){
                            resolve(123);
                        },1000)
                    })
                })
                .then(function(data){//data是上面返回的123
                    return 'hello';//返回的是一个普通的值，默认会产生一个新的Promise对象，被下一次then调用
                })
                .then(function(data){//这个data是上面返回的普通值
                    console.log(data)
                })
```

###     2.6 Promise常用的API

####         1.实例方法：

```
     a. p.then() 得到异步任务的正确结果,一个参数的时候处理resolve,两个参数的时候可以处理resolve也可以处理reject
     b. p.catch() 获取异常信息，处理reject
     c. p.finally() 成功与否都会执行(暂时不是正式标准)
```

####             例：

```javascript
	<script>
        // console.dir(Promise)
        function foo(){
            return new Promise(function(resolve,reject){
                 setTimeout(function(){
                       // resolve(123);
                       reject("error");
                 },1000)
            })
        }
        /* foo()
        .then(function(data){
         	console.log(data)
        })
        .catch(function(data){
            console.log(data)
        })
        .finally(function(){
            console.log('完成了')
        }) */
        // 等效于
        foo()
        .then(function(data){
             console.log(data)
         },function(data){
             console.log(data)
         })
         .finally(function(){
                 console.log('完成了')
         })
         输出：error和完成了
	</script>
```

####         2.对象方法

#####             a.Promise.all()  

```
	并发处理多个异步任务，所有任务都执行完成才能得到结果
```

#####             b.Promise.race() 

```
	并发处理多个异步任务，只要有一个任务完成就能得到结果
```

#####             c.例：

```javascript
     <script>
        // console.dir(Promise)
        function queryData(url){
            return new Promise(function(resolve,reject){
                var xhr=new XMLHttpRequest();
                xhr.onreadystatechange=function(){
                    if(xhr.readyState!=4) return;
                    if(xhr.readyState==4&&xhr.status==200){
                        //处理正常的情况
                        resolve(xhr.responseText);
                    }else{
                        reject('服务器错误')
                    }
                }
                xhr.open('get',url);
                xhr.send(null);
            });
        }
        var p1=queryData('http://localhost:3000/a1');
        var p2=queryData('http://localhost:3000/a2');
        var p3=queryData('http://localhost:3000/a3');
        /* Promise.all([p1,p2,p3]).then(function(result){
            console.log(result);//['Hello World','Hello Tom','Hello Jerry']
            //三秒后输出一个数组，顺序是传参时候的顺序
        }) */
        Promise.race([p1,p2,p3]).then(function(result){
            console.log(result);//'Hello World'
            // //由于p1执行较快，Promise的then()将获得结果'P1'。p2,p3仍在继续执行，但执行结果将被丢弃。 
        })
    </script>
    路由：
        //Promise.all()和Promise.race()的路由
        app.get('/a1', (req, res) => {
        setTimeout(function () {
            res.send('Hello World!')
        }, 1000)
        });
        app.get('/a2', (req, res) => {
        setTimeout(function () {
            res.send('Hello Tom!')
        }, 2000)
        });
        app.get('/a3', (req, res) => {
        setTimeout(function () {
            res.send('Hello Jerry!')
        }, 3000)
        });
```



## 三、接口调用-fetch用法

###     3.1 fetch概述

####         1.基本特性

```
    a.更加简单的数据获取方式，功能更强大，更灵活，可以看作是xhr的升级版
    b.基于Promise实现
      Fetch会返回Promise fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。
```

####         2.语法结构

```html
    fetch(url,options)
        .then(fn2)
        .then(fn3)
        ....
        .catch(fn)
```

###     3.2 fetch的基本使用

```html
    fetch('/abc')
         .then(data=>{
              return data.text();
              //text()是fetchAPI的一部分，它的返回值是一个Promise实例对象,用于获取后台返回的数据
         })
         .then(data=>{
             //这里得到最终的数据
             console.log(data);
          })
```

###     3.3 fetch请求参数

####         1.常用配置选项

```
    a.method(String):HTTP请求方式,默认为GET(GET POST PUT DELETE)
    b.body(String):HTTP请求参数
    c.headers(Object):HTTP的请求头，默认为{}
```

####         2.GET请求方式的参数传递

#####           a.传统url

```html
    参数的传递使用传统的方法，也就是问号后面添加参数就好了
    fetch('http://localhost:3000/book?id=123')
          .then(data=>{
                return data.text();
          })
          .then(data=>{
                console.log(data);
          })
    路由：
    app.get('/book', (req, res) => {
          res.send('传统url传递参数'+req.query.id)
    });
```

#####           b.Restful形式的URL

```html
    把参数用/添加到后面
    fetch('http://localhost:3000/books/123',{
          method:'get'
          }).then(data=>{
              return data.text();
          }).then(data=>{
              console.log(data)
    路由：
    app.get('/books/:id', (req, res) => {
          res.send('Restful形式的URL传递参数'+req.params.id)
    });
```

####         3.DELETE请求方式的参数传递

```html
    fetch('http://localhost:3000/books/123',{
         method:'delete'//指定methods
         }).then(data=>{
              return data.text();
         }).then(data=>{
              console.log(data)
         })
    路由：
    app.delete('/books/:id', (req, res) => {//方式指定delete
         res.send('Restful形式的URL传递参数'+req.params.id)
    });
```

####         4.POST请求方式的参数传递  

```html
    x-www-form-urlencoded格式：
         fetch('http://localhost:3000/books',{//注意这里可以不需要再添加参数
               method:'post',//指定methods
               body:'uname=lisi&pwd=123',
               headers:{  //请求头，必须要有
                    'Content-type':'application/x-www-form-urlencoded'
               }
               }).then(data=>{
                    return data.text();
               }).then(data=>{
                    console.log(data)
               })

    json格式：
     fetch('http://localhost:3000/books', {
          method: 'post', //指定methods
          body: JSON.stringify({//把json格式的数据转化成json字符串格式
               uname:'张三',
               pwd:'456'
          }),
          headers: {
               'Content-Type': 'application/json'
          }
     }).then(data => {
          return data.text();
     }).then(data => {
          console.log(data)
     })

    路由：
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({
        extended: false
    }));
    app.post('/books', (req, res) => {
         res.send('POST传递参数'+req.body.uname+'.....'+req.body.pwd)
         //body是body-parse这个中间件提供的，因此要先引入这个文件
    });
```

####         5.PUT请求方式的参数传递

```
    与post方法相同，也可以传递两种格式的 
    x-www-form-urlencoded格式：
        fetch('http://localhost:3000/books/123', {//这里可以传递一个参数id
            method: 'put', //指定methods
            body: 'uname=lisi&pwd=123',
            headers: {
                'Content-type': 'application/x-www-form-urlencoded'
            }
        }).then(data => {
            return data.text();
        }).then(data => {
            console.log(data)
        })  


    json格式：
        fetch('http://localhost:3000/books/123', {
            method: 'put', //指定methods
            body: JSON.stringify({//把json格式的数据转化成json字符串格式
                uname:'张三',
                pwd:'789'
            }),
            headers: {
                'Content-Type': 'application/json'
            }
        }).then(data => {
            return data.text();
        }).then(data => {
            console.log(data)
        })


    路由：
        app.use(bodyParser.json());
        app.use(bodyParser.urlencoded({
            extended: false
        }));
        app.put('/books/:id', (req, res) => {
            res.send('PUT传递参数'+req.params.id+'-----'+req.body.uname+'-----'+req.body.pwd)
        });
```

###     3.4 fetch响应结果

####         1.响应数据格式

#####             a.text():将返回体处理成字符串类型

```html
    客户端：
    fetch('http:localhost:3000/json')
          .then(function(data){
                 return data.text();
           }).then(function(data){
                 console.log(data)
                 //返回一个json格式的字符串，不能通过.的形式获取里面的数据，但是可以把它转换成json对象再获取
                 console.log(data.uname)//这样子是不能得到的
                //将json字符串转换为json对象
                var obj=JSON.stringify(data);
                console.log(obj.uname)
          })
```

#####             b.json():将返回结果和JSON.parse(responseText)一样

```html
     客户端
    fetch('http:localhost:3000/json')
          .then(function(data){
               return data.json();
          }).then(function(data){
               console.log(data)//返回一个json格式的对象
               console.log(data.uname)
          })

    路由：
    app.get('/json',(req,res)=>{
         res.json({//注意这里是res.json
                uname:'lisi',
                age:13,
                gender:'male'
         })
    })
```

## 四、接口调用-axios用法

###     4.1 axios的基本特性

```
    官网：http://githube.com/axios/axios
    是一个基于Promise用于浏览器和node.js的http客户端
    它具有以下特征
       支持浏览器和Node.js
       支持Promise
       能拦截请求和响应
       自动转换JSON数据
```

###     4.2 axios的基本用法

```
    axios.get('http://localhost:3000/axiosdata')
         .then(ret=>{
              console.log(ret);//包含了很多属性
              //这个data是一个属性名，是固定的，用于获取后台响应的数据
              console.log(ret.data)//Hello axios
         })

    路由：
    app.get('/axiosdata',(req,res)=>{
        res.send('Hello axios')
    })
```

###     4.3 axios的常用API

```
    get:查询数据
    post:添加数据
    put:修改数据
    delete:删除数据
```

###     4.4 axios的参数传递

####         1.GET传递参数

#####             a.通过URL传递参数

######                 传统url:

```
    axios.get('http://localhost:3000/axios?id=123')
         .then(function(info){
              console.log(info)//这里返回的是一个对象
              console.log(info.data)
         })
    //get路由
     app.get('/axios',(req,res)=>{
         res.send('get传递参数'+req.query.id)
    })
```

######                 restful:

```
    axios.get('http://localhost:3000/axios/456')
        .then(function(info){
             console.log(info)
             console.log(info.data)
        })
    //get路由
    app.get('/axios/:id',(req,res)=>{
       res.send('get传递参数'+req.params.id)//注意这里的参数是通过params获得的
    })
```

#####             b.通过params选项传递参数

```html
    axios.get('http://localhost:3000/axios',{
          params:{
              id:789
          }
    }).then(function(info){
          console.log(info)
          console.log(info.data)
    })  

    路由：
    app.get('/axios',(req,res)=>{
        res.send('get传递参数'+req.query.id)
    })
```

####         2.DELETE传递参数

```
	与GET类似，把方式改为delete就可以了
```

####         3.POST传递参数

#####             a.通过选项传递参数，默认传递的是json格式的数据,推荐使用这个

```
     axios.post('http://localhost:3000/axios',{
           uname:'Tom',
           pwd:123
    }).then(function(info){
           console.log(info);
           console.log(info.data)
    })

    路由：
    app.post('/axios',(req,res)=>{
        res.send('POST传递参数'+req.body.uname+'----'+req.body.pwd)
    })
```

#####             b.通过URLSearchParams传递参数，application/x-www-form-urlencoded

```html
    const params=new URLSearchParams();
    params.append('uname','zhangsan');
    params.append('pwd','555');
    axios.post('http://localhost:3000/axios',params).then(function(info){
          console.log(info);
          console.log(info.data)
    })

    路由：
    app.post('/axios',(req,res)=>{
        res.send('POST传递参数'+req.body.uname+'----'+req.body.pwd)
    })
```

####         4.PUT传递参数

```
    与POST相似，但是，一般要修改数据，需要携带一个id，两种方式都可以使用，推荐使用第一种
    axios.put('http://localhost:3000/axios/123',{//123是id
          uname:'Tom',
          pwd:123
    }).then(function(info){
          console.log(info);
          console.log(info.data)
    })

    路由：
    app.put('/axios/:id',(req,res)=>{
        res.send('POST传递参数'+req.body.uname+'----'+req.body.pwd)
    })
```

###     4.5 axios的响应结果

####         1.响应结果的主要属性

```
    data:实际响应回来的数据
    headers:响应头信息
    status:响应状态码
    statusText:响应状态信息
```

###     4.6 axios的全局配置

####         1.配置公共的请求头/默认地址

```
    axios.defaults.baseURL = '.....'; 
    例：
    axios.defaults.baseURL='http://localhost:3000/';
    axios.get('axiosjson')
         .then(function(info){
              console.log(info.data.uname);
    })
```

####         2.配置超时时间 

```
  axios.defaults.timeout = 2500; 
```

####         3.配置公共的请求头 

```
     axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; 
    例：
    //配置请求头信息
    axios.defaults.headers['mytoken']='hello';
    需要后台配置：
    res.header('Access-Control-Allow-Headers', 'mytoken');
```

####     4.配置公共的 post 的 Content-Type 

```
	axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 
```

### 4.7 axios拦截器

####     1.请求拦截器

```
     在请求发出之前设置一些信息
    //添加一个请求拦截器
    axios.interceptors.request.use(function(config){
          //config是请求的数据
          //这里对发送的信息进行处理
          return config;
    },function(err){
          //处理请求错误的信息
          console.log(err)
    })
```

####     2.响应拦截器

```
    在获取数据之前对数据做一些加工处理
    axios.interceptors.response.use(function(res){
           //res是响应的数据
           //这里对发送的信息进行处理
           return res;
    },function(err){
           //处理请求错误的信息
           console.log(err)
     })
```

### 五、接口调用-async/await用法

####     5.1 async/await的基本用法

```
    async/await是ES7引入的新语法，可以更加方便的进行异步操作
    async关键字用于函数上(async函数的返回值是Promise实例对象)
    await关键字用于async函数当中(await可以得到异步的结果)
```

#####         示例代码：

```
    //传统方式调用
    axios.defaults.baseURL='http:localhost:3000';
    axios.get('axiosdata').then(function(ret){
          console.log(ret.data);
    }) 

    //请求
    async function queryData(){
          var ret=await axios.get('axiosdata');
          console.log(ret);
          console.log(ret.data)
          return ret.data
    }

    queryData().then(function(data){
          console.log(data)
    });
    //await后面要接一个Promise实例对象,我们可以new一个
    async function queryData(){     
          var ret=await new Promise(function(resolve,reject){
              setTimeout(function(){
                    resolve('你好')
              },1000)
          })
          return ret;//这个就是resolve的信息
    }
    queryData().then(function(data){
         console.log(data)//你好
    });
```

####     5.2 async/await处理多个异步请求

```
    例：
        axios.defaults.baseURL = 'http://localhost:3000';
        async function queryData() {
            var info = await axios.get('async1');//info是返回的对象.里面含有data数据
            var ret = await axios.get('async2?info=' + info.data);
            return ret.data;
        }
        queryData().then(function(data){
            console.log(data)
        })
        路由：
        app.get('/async1',(req,res)=>{
            res.send('Hello')
        });
        app.get('/async2',(req,res)=>{
        if(req.query.info=='Hello'){
            res.send('World')
        }else{
            res.send('Error')
        }
        });
```

### 六、基于接口的案例

# 前端路由

## 一、路由的基本概念与原理

###     1.1 路由 

```
    路由是一个比较广义和抽象的概念，路由的本质就是对应关系。 
    在开发中，路由分为：后端路由和前端路由 
```

####         1.后端路由

```
    概念：根据不同的用户URL请求，返回不同的内容
    本质：URL 请求地址与服务器资源之间的对应关系 
    后端路由根据不同的URL地址分发不同的资源 
```

####         2.SPA（Single  Page Application）  

```
    a.后端渲染（存在性能问题）
    b.Ajax前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）
    c.SPA（Single Page Application）单页面应用程序：整个网站只有一个页面，内容的变化通过Ajax局部更新实现、同时支持浏览器地址栏的前进和后退操作
    d.SPA实现原理之一：基于URL地址的hash（hash的变化会导致浏览器记录访问历史的变化、但是hash的变化不会触发新的URL请求）
    e.在实现SPA过程中，最核心的技术点就是前端路由 
```

####         3.前端路由

```
    概念：根据不同的用户事件，显示不同的页面内容
    本质：用户事件与事件处理函数之间的对应关系
    前端路由负责事件监听，触发事件后，通过事件函数渲染不同内容
```

####         4. 实现简易前端路由 

```
 	基于URL中的hash实现（点击菜单的时候改变URL的hash，根据hash的变化控制组件的切换） 
```

###     1.2 Vue router

```
    Vue Router（官网：https://router.vuejs.org/zh/）是 Vue.js 官方的路由管理器。 
    它和 Vue.js 的核心深度集成，可以非常方便的用于SPA应用程序的开发。 
    Vue Router 包含的功能有： 
       支持HTML5 历史模式或 hash 模式
       支持嵌套路由 
       支持路由参数 
       支持编程式路由 
       支持命名路由
```

## 二、vue-route的基本使用

###     2.1 基本使用步骤

####         1.  引入相关的库文件 

```
    <!-- 导入 vue 文件，为全局 window 对象挂载 Vue 构造函数 -->   
    <script src="./lib/vue_2.5.22.js"></script> 
    <!-- 导入 vue-router 文件，为全局 window 对象挂载 VueRouter 构造函数 --> 
    <script src="./lib/vue-router_3.0.2.js"></script> 
```

####         2.  添加路由链接 

```
    <!-- router-link 是 vue 中提供的标签，默认会被渲染为 a 标签 --> 
    <!-- to 属性默认会被渲染为 href 属性 --> 
    <!-- to 属性的值默认会被渲染为 # 开头的 hash 地址 --> 
    <router-link to="/user">User</router-link> 
    <router-link to="/register">Register</router-link> 
```

####         3.  添加路由填充位 

```
    <!-- 路由填充位（也叫做路由占位符） --> 
    <!-- 将来通过路由规则匹配到的组件，将会被渲染到 router-view 所在的位置 -->   
    <router-view></router-view> 
```

####         4.  定义路由组件 

```
    var User = { 
        template: '<div>User</div>' 
    } 
    var Register = { 
        template: '<div>Register</div>' 
    } 
```

####         5.  配置路由规则并创建路由实例 

```html
    // 创建路由实例对象     
    var router = new VueRouter({     
        // routes 是路由规则数组     
        routes: [       
             // 每个路由规则都是一个配置对象，其中至少包含 path 和 component 两个属性：       
             // path 表示当前路由规则匹配的 hash 地址       
             // component 表示当前路由规则对应要展示的组件       
             { path:'/user',component: User}, 
             {path:'/register',component: Register} 
        ] 
     }) 
```

####         6.  把路由挂载到 Vue 根实例中 

```
    new Vue({ 
        el: '#app',      
         // 为了能够让路由规则生效，必须把路由对象挂载到 vue 实例对象上      
         router 
    });
```

####         示例：

```javascript
    <body>
        <!-- 引入相关库文件 -->
        <script src="lib/vue_2.5.22.js"></script>
        <script src="lib/vue-router_3.0.2.js"></script>
        <div id="app">
            <!-- 添加路由链接 -->
            <router-link to='/user'>User</router-link>
            <router-link to='/register'>Register</router-link
            <!-- 路由填充位/占位符 -->
            <router-view></router-view>
        </div
        <script>
            //定义路由组件
            const User={
                template:'<h1>User组件</h1>'
            }
            const Register={
                template:'<h1>Register组件</h1>'
            }
            //创建路由实例对象并配置路由规则
            //创建路由实例对象
            const router=new VueRouter({
                //routes是所有的路由规则
                routes:[
                    {
                        path:'/user',//这个对应的是添加路由链接时提供的hash地址
                        component:User//这里要填上要使用的路由组件，只接受路由对象，不接受路由字符串
                        // 意思就是：如果用户访问的hash地址是user，那就展示User这个路由组件
                    },
                    {
                        path:'/register',//这个对应的是添加路由链接时提供的hash地址
                        component:Register//这里要填上要使用的路由组件，只接受路由对象，不接受路由字符串
                    }
                ]
            })
            //vue实例
            var vm=new Vue({
                el:'#app',
                data:{},
                //挂载路由实例对象
                // router:router,
                //ES6中如果属性名和属性值是一样的可以简写成一个
                router
            })
        </script>
    </body>
```

### 2.2 路由重定向

```
    路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C(比如说我们打开某个页面的时候我们希望有一个默认显示的页面) ，从而展示特定的组件页面； 通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向： 
        var router = new VueRouter({ 
            routes: [       
                // 其中，path 表示需要被重定向的原地址，redirect 表示将要被重定向到的新地址       
            {
                path:'/', 
                redirect: '/user'
            }, 
            {path:'/user',component: User}, 
            {path:'/register',component: Register} 
            ] 
        })
```

## 三、vue-router嵌套路由

###     3.1 嵌套路由用法 

####         1.嵌套路由功能分析

```
    点击父级路由链接显示模板内容 
    模板内容中又有子级路由链接
    点击子级路由链接显示子级模板内容 
```

####         2. 父路由组件模板 

```
    父级路由链接
    父组件路由填充位 
    <p> 
       <router-link to="/user">User</router-link> 
       <router-link to="/register">Register</router-link> 
    </p> 
    <div>       
        <!-- 控制组件的显示位置 -->       
        <router-view></router-view> 
    </div> 
```

####         3. 子级路由模板 

```
    子级路由链接
    子级路由填充位
     const Register = { 
           template: `
              <div>       
                  <h1>Register 组件</h1>       
                  <hr/> 
                  <router-link to="/register/tab1">Tab1</router-link> 
                  <router-link to="/register/tab2">Tab2</router-link> 
                  <!-- 子路由填充位置 -->       
                  <router-view/> //这个可以自闭合，也可以像之前那样写，写个标签形式
                </div>` 
    } 
```

####         4. 定义子组件

```
    const Tab1={
         template:'<h3>tab1</h3>'
    }
    const Tab2={
         template:'<h3>tab2</h3>'
    }
```

####         5. 嵌套路由配置 

```
    父级路由通过children属性配置子级路由 
    const router = new VueRouter({     
        routes: [       
            { path: '/user', component: User },       
            {         
                path: '/register',         
                component: Register,         
                // 通过 children 属性，为 /register 添加子路由规则         
                children: [          
                    { path: '/register/tab1', component: Tab1 },           
                    { path: '/register/tab2', component: Tab2 }         
                ]       
             }     
         ]  
    }) 
```

## 四、vue-router动态路由匹配

```
     如果有一些路由规则一部分是完全一样的，只有一部分是动态变化的，我们可以把这些动态变化的部分形成路由参数，这些路由参数就叫做路由动态匹配。 
```

####     4.1 动态匹配路由的基本用法

```
    应用场景：通过动态路由参数的模式进行路由匹配 
    路由配置：
        var router = new VueRouter({ 
            routes: [     
                // 动态路径参数 以冒号开头     
                { path: '/user/:id', component: User } 
            ] 
        }) 

    定义路由组件：
    const User = {   
        // 路由组件中通过$route.params获取路由参数   
        template: '<div>User {{ $route.params.id }}</div>' 
    }
```

####     4.2 路由组件传递参数

```
	$route与对应路由形成高度耦合，不够灵活，所以可以使用props将组件和路由解耦 
```

#####         1.props的值为布尔类型 

```
    路由传递参数：
    const router = new VueRouter({ 
        routes: [       
            // 如果 props 被设置为 true，route.params 将会被设置为组件属性       
            { path: '/user/:id', 
              component: User, 
              props: true } 
         ] 
    }) 

    组件接收参数
    const User = {     
        props: ['id'], 
        // 使用 props 接收路由参数     
        template: '<div>用户ID：{{ id }}</div>'  // 使用路由参数   
    }
```

#####         2.props的值为对象类型 

```
    const router = new VueRouter({ 
        routes: [       
            // 如果 props 是一个对象，它会被按原样设置为组件属性       
            { path: '/user/:id', //这个id，不再生效，不会打印出来
              component: User,
              props: { 
                   uname: 'lisi', 
                   age: 12 
              }
             } 
         ] 
    }) 

    const User = { 
        props: ['uname', 'age'],     
        template: ‘<div>用户信息：{{ uname + '---' + age}}</div>'  
    } 
```

#####         3. props的值为函数类型 

```
    const router = new VueRouter({ 
        routes: [      
            // 如果 props 是一个函数，则这个函数接收 route 对象为自己的形参       
            { path: '/user/:id',  
              component: User,  
              props: route => ({ 
                 uname: 'zs', //静态
                 age: 20, 
                 id: route.params.id //动态匹配到的
              })
            } 
            //route是路由中的动态参数对象,上面path中有多少个参数项(id对应的位置)，route里面就有多少个参数值
        ] 
    })            
    const User = { 
        props: ['uname', 'age', 'id'],     
        template: ‘<div>用户信息：{{ uname + '---' + age + '---' + id}}</div>'   
    }
```

## 五、vue-router命名路由

###     5.1 命名路由的配置规则 

```
    为了更加方便的表示路由的路径，可以给路由规则起一个别名，即为“命名路由”。 
    const router = new VueRouter({ 
        routes: [ 
            { 
                path: '/user/:id', 
                name: 'user', //添加了一个name属性，这个name就代表了这个路由规则
                component: User 
            } 
        ] 
    }) 

    命名路由作用：
    点击这个链接的时候调转到name所指定的路由规则中，还可以传递参数
    <router-link :to="{ name: 'user', params: { id: 123 }}">User</router-link> 
        在to前面加上属性绑定的冒号:
        name是对应要绑定的路由规则
        params参数，路由规则中定义的参数名叫什么，这里也需要一一对应
        router.push({ name: 'user', params: { id: 123 }}) 
```

## 六、vue-router编程式导航

###     5.1 页面导航的两种方式 

```
    1.声明式导航：通过点击链接实现导航的方式，叫做声明式导航 
      例如：普通网页中的 <a></a> 链接 或 vue 中的 <router-link></router-link> 
    2.编程式导航：通过调用JavaScript形式的API实现导航的方式，叫做编程式导航
      例如：普通网页中的 location.href  
```

###   5.2 编程式导航基本用法 

#### 1.常用的编程式导航 API 如下：

```
this.$router.push('hash地址') 跳转到指定的组件页面
this.$router.go(n)  为了实现前进和后退，n=1,历史记录中前进一位，n=-1，历史记录中后退一位
```

#### 2.this.$router.push('hash地址')

```javascript
    const User = {       
        template: '<div><button @click="goRegister">跳转到注册页面</button></div>',        
        methods: { 
            goRegister: function(){           
                // 用编程的方式控制路由跳转           
                this.$router.push('/register'); 
            } 
        } 
    } 
```

#### 3.this.$router.go(n)

```javascript
    const Register={
        template:`
            <div>
                <h1>Register组件</h1>
                <button @click='goBack'>后退</button>
            </div>
            `,
        methods: {
            goBack(){
                this.$router.go(-1) 
            }
        },
    }
```

###     5.3 编程式导航参数规则

```javascript
    1.router.push() 方法的参数规则 
    a.字符串(路径名称)   
        router.push('/home')   
    b.对象
        router.push({ path: '/home' })
    c.命名的路由(传递参数)
        router.push({ name: '/user', params: { userId: 123 }})   
    d.带查询参数，变成 /register?uname=lisi
        router.push({ path: '/register', query: { uname: 'lisi' }}) 
```

## 七、基于vue-router的案例

### 1.用到的路由技术要点： 

```
    路由的基础用法
    嵌套路由 
    路由重定向
    路由传参
    编程式导航 
```

###  2.根据项目的整体布局划分好组件结构，通过路由导航控制组件的显示 

```
    1. 抽离并渲染 App 根组件 
    2. 将左侧菜单改造为路由链接 
    3. 创建左侧菜单对应的路由组件 
    4. 在右侧主体区域添加路由占位符 
    5. 添加子路由规则 
    6. 通过路由重定向默认渲染用户组件 
    7. 渲染用户列表数据 
    8. 编程式导航跳转到用户详情页 
    9. 实现后退功能
```

# 前端工程化

## 一、模块化相关规范

###     1.1 模块化概述 

####         1.传统开发模式的主要问题 ：

```
    命名冲突：js文件中变量的重名
    文件依赖：js文件之间无法实现相互引用
```

####         2.通过模块化解决上述问题  

```
    a.模块化就是把单独的一个功能封装到一个模块（文件）中，模块之间相互隔离，但是可以通过特定的接口公开内部成 员，也可以依赖别的模块
    b.模块化开发的好处：方便代码的重用，从而提升开发效率，并且方便后期的维护
```

###     1.2 浏览器端模块化规范

####         1. AMD 

```
   Require.js (http://www.requirejs.cn/)         
```

####         2. CMD 

```
   Sea.js (https://seajs.github.io/seajs/docs/)
```

###     1.3 服务器端模块规范

####         1.CommonJS

```
    ① 模块分为 单文件模块 与 包 
    ② 模块成员导出：module.exports 和 exports 
    ③ 模块成员导入：require('模块标识符')
```

###     1.4 大一统的模块化规范 – ES6模块化 

```
    在 ES6 模块化规范诞生之前，Javascript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范。 
    但是，这些社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化标准，例如： 
       AMD 和 CMD 适用于浏览器端的 Javascript 模块化;
       CommonJS 适用于服务器端的 Javascript 模块化;    
    因此，ES6 语法规范中，在语言层面上定义了 ES6 模块化规范，是浏览器端与服务器端通用的模块化开发规范。  
    ES6模块化规范中定义：
       每个 js 文件都是一个独立的模块 
       导入模块成员使用 import 关键字 
       暴露模块成员使用 export 关键字 
```

####         1.Node.js中通过babel体验ES6模块化

```
    babel是一个语法转换工具，可以把高级的，有兼容的代码转换为低级的，无兼容性的代码
    步骤：
    ① npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node  //安装相关依赖包
    ② npm install --save @babel/polyfill   //安装相关依赖包
    ③ 项目跟目录创建文件 babel.config.js 
    ④ babel.config.js 文件内容如下代码 
      const presets = [ //presets是语法转换的数组，里面提供了一些在语法转换期间可能会用到的语法转换插件
           ["@babel/env", { 
               targets: { //转换之后的代码要支持这些浏览器
                   edge: "17", 
                   firefox: "60", 
                   chrome: "67", 
                   safari: "11.1" 
                } 
            }] 
       ]; 
       module.exports = { presets }; 
    ⑤ 通过 npx babel-node index.js 执行代码 //index.js是要执行的文件
```

###      1.5 ES6 模块化的基本语法 

####         1.默认导出与默认导入

#####             a.默认导出语法 export default 默认导出的成员

```
    // 当前文件模块为 m1.js 
    let a = 10   // 定义私有成员 a 和 c 
    let c = 20 
    let d = 30   // 外界访问不到变量 d ,因为它没有被暴露出去 
    function show() {}  //定义私有方法               
    export default {   // 将本模块中的私有成员暴露出去，供其它模块使用 
        a, 
        c, 
        show 
    }
    注意：每个模块中，只允许使用唯一的一次 export default，否则会报错！  
```

#####             b.默认导入语法 import 接收名称 from '模块标识符'

```
    import m from './m1.js' // 导入模块成员m1,并使用一个变量m来接收    
    console.log(m)   //输出 { a: 10, c: 20, show: [Function: show] }
```

####         2.按需导出与按需导入 

#####             a.按需导出语法 export let s1 = 10      

```
    // 当前文件模块为 m1.js                
    export let s1 = 'aaa'  // 向外按需导出变量 s1   
    export let s2 = 'ccc'  // 向外按需导出变量 s2                 
    export function say () {  // 向外按需导出方法 say 
          console.log('cccc')
    }  
```

#####             b.按需导入语法 import { s1 } from '模块标识符' 

```
     import { s1, s2 as ss2, say } from './m1.js'  // 导入模块成员
       //给s2取了一个别名ss2   
     console.log(s1) // 打印输出 aaa   
     console.log(ss2) // 打印输出 ccc   
     console.log(say) // 打印输出 [Function: say]
```

####         3.默认和按需的结合

```
    同一个文件里面可以同时存在默认导出和按需导出，但是默认导出只能有一个，按需导出可以有多个，使用
    导入：
    import m1,{s1, s2 as ss2, say} from './m1.js'
    m1代表默认导出，后面的对象表示按需导出
```

####         4.直接导入并执行模块代码

```
	有时候，我们只想单纯执行某个模块中的代码，并不需要得到模块中向外暴露的成员，此时，可以直接导入并执行模块代码。
    // 当前文件模块为 m2.js  
    // 在当前模块中执行一个 for 循环操作 
    for(let i = 0; i < 3; i++) { 
        console.log(i) 
    } 
    // 直接导入并执行模块代码   
    import './m2.js'  //打印012
```

## 二、webpack

###     2.1 当前 Web 开发面临的困境 

```
    文件依赖关系错综复杂 
    静态资源请求效率低 
    模块化支持不友好 
    浏览器对高级 Javascript 特性兼容程度较低
```

###     2.2 webpack 概述       

```
    webpack 是一个流行的前端项目构建工具（打包工具），可以解决当前 web 开发中所面临的困境。 
    webpack 提供了友好的模块化支持，以及代码压缩混淆、处理 js 兼容问题、性能优化等强大的功能，从而让程序员把 工作的重心放到具体的功能实现上，提高了开发效率和项目的可维护性。 
    目前绝大多数企业中的前端项目，都是基于 webpack 进行打包构建的。
```

 

###      2.3 webpack 的基本使用 

####         1.创建列表隔行变色项目       

```
    ① 新建项目空白目录，并运行 npm init –y 命令，初始化包管理配置文件 package.json 
    ② 新建 src 源代码目录 
    ③ 新建 src -> index.html 首页 
    ④ 初始化首页基本的结构 
    ⑤ 运行 npm install jquery –S 命令，安装 jQuery 
    ⑥ 通过模块化的形式，实现列表隔行变色效果  
```

####         2. 在项目中安装和配置 webpack 

```
    ① 运行 npm install webpack webpack-cli –D 命令，安装 webpack 相关的包 
    ② 在项目根目录中，创建名为 webpack.config.js 的 webpack 配置文件 
    ③ 在 webpack 的配置文件中，初始化如下基本配置：
      module.exports = {   
            mode: 'development' 
            // mode 用来指定构建模式,development开发模式表示转换出的代码不会进行压缩与混淆，
            production表示发布模式，转换的代码会有压缩和混淆
      }
    ④ 在 package.json 配置文件中的 scripts 节点下，新增 dev 脚本如下： 
      "scripts": {  
            "dev": "webpack" // script 节点下的脚本，可以通过 npm run 执行 
       }  
    ⑤ 在终端中运行 npm run dev 命令，启动 webpack 进行项目打包 
```

####         3. 配置打包的入口与出口 

```
    a.webpack 的 4.x 版本中默认约定： 
        打包的入口文件为 src  -> index.js 
        打包的输出文件为 dist -> main.js 
    b.如果要修改打包的入口与出口，可以在 webpack.config.js 中新增如下配置信息： 
        const path = require('path')  // 导入 node.js 中专门操作路径的模块               
        module.exports = {   
            entry: path.join(__dirname, './src/index.js'),  // 打包入口文件的路径                      
            output: {     
                path: path.join(__dirname, './dist'), // 输出文件的存放路径                             
                filename: 'bundle.js' // 输出文件的名称   
            } 
        } 
```

####         4. 配置 webpack 的自动打包功能 

#####             需要打包的原因：

​                每次修改代码之后刷新浏览器是不生效的，都需要手动打包执行之后才能生效，这样有些麻烦，所以就需要自动打包。

#####             步骤：

```
    ① 运行 npm install webpack-dev-server –D 命令，安装支持项目自动打包的工具 
    ② 修改 package.json -> scripts 中的 dev 命令如下： 
        "scripts": {   
            "dev": "webpack-dev-server" // script 节点下的脚本，可以通过 npm run 执行 
        }
    ③ 将 src -> index.html 中，script 脚本的引用路径，修改为 "/bundle.js"
        我们在根目录中可能看不到这个bundle.js,webpack-dev-server帮我们生成的bundle.js这个文件并没有放在实际的物理磁盘上，而是放到了内存总，是个虚拟的，看不见的文件
    ④ 运行 npm run dev 命令，重新进行打包
    ⑤ 在浏览器中访问 http://localhost:8080 地址，查看自动打包效果 
    注意：
    webpack-dev-server 会启动一个实时打包的 http 服务器
    webpack-dev-server 打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的 
```

####         5. 配置 html-webpack-plugin 生成预览页面 

#####             需要预览页面原因：

```
 	我们访问根路径的时候会看到项目目录文件，打开对应的文件才能查看，但是我们希望访问根目录就能看到页面，所以需要预览页面
```

#####             步骤：

```
    ① 运行 npm install html-webpack-plugin –D 命令，安装生成预览页面的插件 
    ② 修改 webpack.config.js 文件头部区域，添加如下配置信息： 
      // 导入生成预览页面的插件，得到一个构造函数 
      const HtmlWebpackPlugin = require('html-webpack-plugin') 
      const htmlPlugin = new HtmlWebpackPlugin({ // 创建插件的实例对象   
           template: './src/index.html', // 指定要用到的模板文件   
           filename: 'index.html' // 指定生成的文件的名称，该文件存在于内存中，在目录中不显示 
      }) 
    ③ 修改 webpack.config.js 文件中向外暴露的配置对象，新增如下配置节点： 
      module.exports = {   
           plugins: [ htmlPlugin ] // plugins 数组是 webpack 打包期间会用到的一些插件列表
      } 
```

####         6. 配置自动打包相关的参数 

```
    原因：当运行程序之后，我们需要运行出的结果给的那个地址复制到页面中去运行，比较麻烦，我们希望可以运行完成的那一刻就去打开浏览器，并展示相应的页面
    // package.json中的配置   
    // --open 打包完成后自动打开浏览器页面   
    // --host 配置 IP 地址   
    // --port 配置端口   
    "scripts": { 
         "dev": "webpack-dev-server --open --host 127.0.0.1 --port 8888" 
          //默认的地址是localhost:8080,如果open后面没有配置host和post,就默认是这个，我们也可以改成别的，比如上面那个
    },
```

###     2.3  webpack 中的加载器 

####         1. 通过 loader 打包非 js 模块 

```
    在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块，其他非 .js 后缀名结 尾的模块，webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！ 
    loader 加载器可以协助 webpack 打包处理特定的文件模块，比如： 
    less-loader 可以打包处理 .less 相关的文件 
    sass-loader 可以打包处理 .scss 相关的文件 
    url-loader  可以打包处理 css 中与 url 路径相关的文件
```

####         2. loader 的调用过程 

###     2.4 webpack 中加载器的基本使用

```
 常见文件类型：CSS  LESS  SCSS  PostCSS  JavaScript  Image/Font  Vue   
```

####         1. 打包处理 css 文件       

```
  ① 运行 npm i style-loader css-loader -D 命令，安装处理 css 文件的 loader 
            ② 在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： 
                // 所有第三方文件模块的匹配规则   
                module: { 
                    rules: [ 
                        { test: /\.css$/, use: ['style-loader', 'css-loader'] } 
                    ] 
                } 
                其中：
                    test：表示匹配的文件类型，test接收一个正则表达式 
                    use：表示对应要调用的 loader 
            注意：
                use 数组中指定的 loader 顺序是固定的
                多个 loader 的调用顺序是：从后往前调用 
```

####         2. 打包处理 less 文件 

```
    ① 运行 npm i less-loader less -D 命令 
    ② 在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： 
       // 所有第三方文件模块的匹配规则   
       module: { 
            rules: [ 
                 { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] } 
            ] 
        } 
```

####         3. 打包处理 scss 文件 

```
    ① 运行 npm i sass-loader node-sass -D 命令 
    ② 在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： 
         // 所有第三方文件模块的匹配规则   
         module: { 
              rules: [ 
                  { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] } 
              ] 
         } 
```

####         4. 配置 postCSS 自动添加 css 的兼容前缀 

```
    ① 运行 npm i postcss-loader autoprefixer -D 命令 
    ② 在项目根目录中创建 postcss 的配置文件 postcss.config.js，并初始化如下配置： 
      const autoprefixer = require('autoprefixer') // 导入自动添加前缀的插件
      module.exports = {     
            plugins: [ autoprefixer ] // 挂载插件   
      } 
    ③ 在 webpack.config.js 的 module -> rules 数组中，修改 css 的 loader 规则如下： 
       module: { 
           rules: [ 
               { test:/\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] } 
           ] 
           //如果rules数组中已经有对.css的处理，那就把use里面新添加的loader加到已经有的那个就可以了
       } 
```

####         5. 打包样式表中的图片和字体文件 

```
    ① 运行 npm i url-loader file-loader -D 命令 
    ② 在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下：
       module: { 
            rules: [ 
                {  
                  test: /\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/,  
                  use: 'url-loader?limit=16940' 
                 } 
             ] 
       } 
     其中 ? 之后的是 loader 的参数项。 
     limit 用来指定图片的大小，单位是字节(byte),只有小于 limit 大小的图片，才会被转为 base64 图片。
```

####         6. 打包处理 js 文件中的高级语法 

```
    ① 安装babel转换器相关的包：npm i babel-loader @babel/core @babel/runtime -D 
    ② 安装babel语法插件相关的包：
      npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D  
    ③ 在项目根目录中，创建 babel 配置文件 babel.config.js 并初始化基本配置如下： 
      module.exports = { 
            presets: [ '@babel/preset-env' ], 
            plugins: [ '@babel/plugin-transform-runtime', '@babel/plugin-proposal-class-properties' ] 
      }
    ④ 在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： 
        // exclude 为排除项，表示 babel-loader 不需要处理 node_modules 中的 js 文件   
      { test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ } 
```

## 三、Vue单文件组件

###     3.1 传统组件的问题和解决方案 

#### 		1.问题

```
    1. 全局定义的组件必须保证组件的名称不重复 
    2. 字符串模板缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \ 
    3. 不支持 CSS 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏 
    4. 没有构建步骤限制，只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器（如：Babel） 
```

#### 2.解决方案 

```
	针对传统组件的问题，Vue 提供了一个解决方案 —— 使用 Vue 单文件组件。
```

### 3.2 Vue 单文件组件的基本用法 

####     1.单文件组件的组成结构 

```
    template 组件的模板区域 
    script 业务逻辑区域 
    style 样式区域
    例： 文件后缀是.vue
        <template>     
            <!-- 这里用于定义Vue组件的模板内容 -->   
        </template> 
        <script>     
            // 这里用于定义Vue组件的业务逻辑     
            export default {       
                data: () { return {} }, // 私有数据       
                methods: {} // 处理函数       
                // ... 其它业务逻辑     
            } 
        </script>            
        <style scoped>     
            /* 这里用于定义组件的样式 */   
        </style> 
```

### 3.3 webpack 中配置 vue 组件的加载器 

```
    ① 运行 npm i vue-loader vue-template-compiler -D 命令 
    ② 在 webpack.config.js 配置文件中，添加 vue-loader 的配置项如下： 
        const VueLoaderPlugin = require('vue-loader/lib/plugin') 
        //引入进来的这个是一个构造函数，在插件引用的时候new一个构造函数的实例
        module.exports = { 
            module: { 
                rules: [       
                    // ... 其它规则       
                    { test: /\.vue$/, loader: 'vue-loader' } 
                ] 
            }, 
            plugins: [     
                // ... 其它插件     
                new VueLoaderPlugin() //必须要有的插件！   
            ] 
        } 
```

### 3.4 在 webpack 项目中使用 vue 

```
    ① 运行  npm i vue -S 安装 vue 
    ② 在 src -> index.js 入口文件中，通过 import Vue from 'vue' 来导入 vue 构造函数 
    ③ 创建 vue 的实例对象，并指定要控制的 el 区域 
    ④ 通过 render 函数渲染 App 根组件

    示例代码：
    // 1. 导入 Vue 构造函数 
    import Vue from 'vue' 
    // 2. 导入 App 根组件 
    import App from './components/App.vue'  
    const vm = new Vue({   
    // 3. 指定 vm 实例要控制的页面区域   
    el: '#app',   
    // 4. 通过 render 函数，把指定的组件渲染到 el 区域中   
    render: h => h(App) 
    }) 
```

### 3.5 webpack 打包发布 

```
上线之前需要通过webpack将应用进行整体打包，可以通过 package.json 文件配置打包命令： 
    // 在package.json文件中配置 webpack 打包命令    
    // 该命令默认加载项目根目录中的 webpack.config.js 配置文件    
"scripts": {      
 	// 用于打包的命令      
 "build": "webpack -p",      
 	// 用于开发调试的命令      
 "dev": "webpack-dev-server --open --host 127.0.0.1 --port 3000", 
    }, 
命令行运行npm run build命令之后，会读取webpack.config.js文件中的相关打包配置，比如入口出口文件，相关插件，规则等等，会把生成的项目放大到dist目录中
```

## 四、Vue脚手架

###      4.1 Vue 脚手架的基本用法 

```
	Vue 脚手架(是一个命令行工具)用于快速生成 Vue 项目基础架构，其官网地址为：https://cli.vuejs.org/zh/ 
```

####         使用步骤 ：

#####         1. 安装 3.x 版本的 Vue 脚手架： 

```
 	npm install -g @vue/cli 
```

#####         2.基于3.x版本的脚手架创建vue项目(三种方式)

######             1. 基于 交互式命令行 的方式，创建 新版 vue 项目       

```
    vue create my-project(项目名称) 
    示例：
    a.vue create vue_proj_01
    b.? Please pick a preset: 创建项目的方式
       default (babel, eslint) 默认创建项目
       > Manually select features 手动创建项目
    c.? Check the features needed for your project: 
      (Press <space> to select, <a> to toggle all, <i> to invert selection)  选择要安装的功能 
      (*) Babel  安装
      ( ) TypeScript  不安装
      ( ) Progressive Web App (PWA) Support
      (*) Router
      ( ) Vuex
      ( ) CSS Pre-processors
      (*) Linter / Formatter
      ( ) Unit Testing
      ( ) E2E Testing 
    d.? Use history mode for router? 
      (Requires proper server setup for index fallback in production) (Y/n) n  
      是否安装历史模式的路由，我们安装hash模式的路由，选择No 
    e.? Pick a linter / formatter config: 选择ESlint的版本
      ESLint with error prevention only
      ESLint + Airbnb config
      > ESLint + Standard config  //标准模式版本
      ESLint + Prettier    
    f.? Pick additional lint features: (Press <space> to select, <a> to toggle all, <i> to invert selection) 
     什么时候进行ESlint语法规则的校验
      >(*) Lint on save
      ( ) Lint and fix on commit  
    g.? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)
      选择这些配置文件是创建单独文件还是统一放在package.json 中
      > In dedicated config files //创建单独的配置文件
      In package.json   
    h.? Save this as a preset for future projects? (y/N) N 
      是否将我们上面的选择作为一个模板保存
    i.开始创建项目，下载各种依赖包等等
    j.进入项目根目录 cd vue_proj_01
    k.输入 npm run serve 运行项目
       App running at://项目对应地址
      - Local:   http://localhost:8080/
      - Network: http://192.168.1.101:8080/
```

######             2. 基于 图形化界面 的方式，创建 新版 vue 项目   

   vue ui
                示例：     
        a.命令行 vue ui 打开创建面板

 b.点击创建，选择项目路径

​		<img src="https://github.com/shan5336/-/blob/master/assets/vue/1.png style="zoom: 50%;" />

​           

  c.创建项目面板

<img src="https://github.com/shan5336/-/blob/master/assets/vue/2.png" style="zoom:50%;" />

   d.选择创建方式，这里选择手动

<img src="https://github.com/shan5336/-/blob/master/assets/vue/3.png" style="zoom:50%;" />
                    e.选择要安装的功能

<img src="https://github.com/shan5336/-/blob/master/assets/vue/4.png" style="zoom:50%;" />

<img src="https://github.com/shan5336/-/blob/master/assets/vue/5.png" style="zoom:50%;" />

​         f.选择路由模式，ESlint版本

<img src="https://github.com/shan5336/-/blob/master/assets/vue/6.png" style="zoom:50%;" />

​        g.保存预设

<img src="https://github.com/shan5336/-/blob/master/assets/vue/7.png" style="zoom:50%;" />

​      h.项目仪表盘

<img src="https://github.com/shan5336/-/blob/master/assets/vue/8.png" style="zoom: 33%;" />

​     i.相关任务

<img src="https://github.com/shan5336/-/blob/master/assets/vue/9.png" style="zoom:33%;" />



######             3. 基于 2.x 的旧模板，创建 旧版 vue 项目    

```
     npm install -g @vue/cli-init 
     vue init webpack my-project 
    示例:
    a.npm install -g @vue/cli-init 
    b.vue init webpack my-project 
    c.? Project name (vue_proj_03) 项目名称，回车选择默认项目名称
    d.? Project description (A Vue.js project) 回车
    e.? Author (zhuSS <2233142707@qq.com>) 回车选默认
    f.? Vue build 选择版本
      Runtime + Compiler: recommended for most users  //完整版体积大
      > Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - render functions are required elsewhere  //简洁版的，使用render
    g.? Install vue-router? (Y/n) Y      
    h.? Use ESLint to lint your code? (Y/n) Y  代码规范性的校验
    i.? Pick an ESLint preset //ESlint版本
      > Standard (https://github.com/standard/standard) //标准版本
      Airbnb (https://github.com/airbnb/javascript)
      none (configure it yourself)  
     j.? Set up unit tests (Y/n) n 单元测试
     k.? Setup e2e tests with Nightwatch? (Y/n) n //e2e测试
     l.? Should we run `npm install` for you after the project has been created? (recommended) (Use arrow keys)
       > Yes, use NPM
       Yes, use Yarn
       No, I will handle that myself     
```

###     4.2 Vue 脚手架生成的项目结构分析 

```
    node_modules: 项目依赖包
    public：静态资源目录
    src:组件源代码目录
       assets:可能会用到的资源，图片，样式表等等
       components:组件
       router:路由
       views:视图组件
       App.vue:项目的根组件
       main.js:项目打包入口文件
    .browserslistrc:
    .editorconfig:
    .eslintrc.js:ESlint语法相关的配置文件
    .gitignore:git的忽略文件
    babel.config.js:babel配置文件
    package.json:包管理配置文件
    package-lock.json:
    postcss.config.js:postcss配置文件
    README.md:
```

###     4.3  Vue 脚手架的自定义配置 (两种方式)

####         1. 通过 package.json 配置项目 

```
    // 必须是符合规范的json语法   
       "vue": { 
           "devServer": { //打包期间服务器的配置
                 "port": "8888", //端口号
                 "open" : true //打包成功自动打开浏览器
             } 
        }
    注意：不推荐使用这种配置方式。因为 package.json 主要用来管理包的配置信息；为了方便维护，推荐将 vue 脚 手架相关的配置，单独定义到 vue.config.js 配置文件中。 
```

####         2. 通过单独的配置文件配置项目 

```
    ① 在项目的跟目录创建文件 vue.config.js 
    ② 在该文件中进行相关配置，从而覆盖默认配置 
      // vue.config.js 
      module.exports = { 
           devServer: { 
                 port: 8888 
           } 
     }
```

## 五、Element-UI的基本使用

```
Element-UI：一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。 
官网地址为： http://element-cn.eleme.io/#/zh-CN
```

### 1. 基于命令行方式手动安装 

```
① 安装依赖包 npm i element-ui –S 
② 导入 Element-UI 相关资源 
    在入口文件main.js中导入
    // 导入组件库   
    import ElementUI from 'element-ui';   
    // 导入组件相关样式   
    import 'element-ui/lib/theme-chalk/index.css';   
    // 配置 Vue 插件   
    Vue.use(ElementUI); 
```

### 2. 基于图形化界面自动安装 

```
① 运行 vue ui 命令，打开图形化界面 
② 通过 Vue 项目管理器，进入具体的项目配置面板 
③ 点击 插件 -> 添加插件，进入插件查询面板 
④ 搜索 vue-cli-plugin-element 并安装 
⑤ 配置插件，实现按需导入 import on demand，从而减少打包后项目的体积 
```

# Vuex

## 一、Vuex概述

###     1.1 组件之间共享数据的方式 

```
	父向子传值：v-bind 属性绑定 
    子向父传值：v-on 事件绑定 
    兄弟组件之间共享数据： EventBus 
        $on 接收数据的那个组件 
        $emit 发送数据的那个组件 
```

###     1.2 Vuex 是什么 

```
	 Vuex 是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间数据的共享。 
```

###     1.3 使用 Vuex 统一管理状态的好处 

```
    ① 能够在 vuex 中集中管理共享的数据，易于开发和后期维护 
    ② 能够高效地实现组件之间的数据共享，提高开发效率 
    ③ 存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步 
```

###     1.4 什么样的数据适合存储到 Vuex 中

```
	一般情况下，只有组件之间共享的数据，才有必要存储到 vuex 中；对于组件中的私有数据，依旧存储在组件自身的 data 中即可。  
```

## 二、Vuex的基本使用

###     1. 安装 vuex 依赖包 

```
	npm install vuex --save 
```

###     2. 导入 vuex 包 

```
    import Vuex from 'vuex' 
    Vue.use(Vuex) 
```

###     3. 创建 store 对象 

```
    const store = new Vuex.Store({ 
        // state 中存放的就是全局共享的数据 
        state: { count: 0 } 
    }) 
```

###     4. 将 store 对象挂载到 vue 实例中 

```
	new Vue({ 
		el: '#app', 
        render: h => h(app), 
        router, 
        // 将创建的共享数据对象，挂载到 Vue 实例中 
        // 所有的组件，就可以直接从 store 中获取全局的数据了 
        store 
     }) 
```

###     5.计数器案例

## 三、Vuex的核心概念

###     3.1 核心概念概述       

```
		Vuex 中的主要核心概念如下： 
            State 
            Mutation 
            Action 
            Getter
```

###     3.2 State 

```
    State 提供唯一的公共数据源，所有共享的数据都要统一放到 Store 的 State 中进行存储。 
    1.创建store数据源，提供唯一公共数据  //在index.js中
        const store = new Vuex.Store({ 
            state: { count: 0 } 
        })  

    2.组件访问 State 中数据的第一种方式： 
        this.$store.state.全局数据名称  

    3.组件访问 State 中数据的第二种方式： 
        a. 从 vuex 中按需导入 mapState 函数 
            import { mapState } from 'vuex'  //哪个组件要用就导入到哪个组件
        通过刚才导入的 mapState 函数，将当前组件需要的全局数据，映射为当前组件的 computed 计算属性： 
        b. 将全局数据，映射为当前组件的计算属性 
            computed: { //哪个组件要用就放到哪儿
            ...mapState(['count']) 
            //前面加...表示的是将当前组件需要的全局数据，映射为当前组件的 computed 计算属性
            } 
```

###     3.3 Mutation 

```
    Mutation 用于变更 Store中 的数据
    ① 只能通过 mutation 变更 Store 数据，不可以直接操作 Store 中的数据。Vuex中不推荐使用this.$store.state.全局数据名称 方式去操作store中的数据
    ② 通过这种方式虽然操作起来稍微繁琐一些，但是可以集中监控所有数据的变化。
```

#### 使用方法

##### 第一种方法：this.$store.commit('add')

```
    a. 定义 Mutation  //在store中的index.js中 
        const store = new Vuex.Store({     
            state: { 
                    count: 0 
                }
            },     
            mutations: {    //带s的   
                 add(state) { //这个state就是上面那个state
                     state.count++     //通过.的形式来获取到count   
                 }     
            }   
        })  

    b. 触发mutation(调用)
        methods: {  //哪个组件需要使用就添加到哪里
            handle1() { 
                 // 触发 mutations 的第一种方式 通过commit调用mutations中定义的参数
                 this.$store.commit('add') 
             } 
        }

    c. 传递参数
        定义Mutation   
        const store = new Vuex.Store({    //store中的index.js 
            state: { 
                     count: 0
                }
            },     
            mutations: {       
                 addN(state, step) { 
                     // 变更状态 
                     state.count += step       
                 }
             }   
        }) 
        触发mutation 
        methods: {  //哪个组件使用就添加到哪里
             handle2() { 
                 // 在调用 commit 函数， 
                 // 触发 mutations 时携带参数 
                 this.$store.commit('addN', 3) 
             } 
        }   
```

##### 第二种方法：...mapMutations(['add', 'addN']) 

```
    this.$store.commit() 是触发 mutations 的第一种方式，触发 mutations 的第二种方式： 

    1.从 vuex 中按需导入 mapMutations 函数 
        import { mapMutations } from 'vuex' //哪个组件需要使用就在那里导入

    通过刚才导入的 mapMutations 函数，将需要的 mutations 函数，映射为当前组件的 methods 方法： 
    2.将指定的 mutations 函数，映射为当前组件的 methods 函数 
        methods: { //在需要使用的组件中导入
         ...mapMutations(['add', 'addN']) 
        } 
```

###     3.4 Action 

```
    Action 用于处理异步任务。 
    如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过触发 Mutation 的方式间接变更数据。
```

#### 1.第一种方式 ：this.$store.dispatch()

```
    a.定义 Action   //store中的index.js
        const store = new Vuex.Store({     
        // ...省略其他代码     
            mutations: { 
                add(state) {         
                    state.count++       
                }     
            },     
            actions: {       
                addAsync(context) {  //这个context我们可以看作是我们New出来的哪个实例对象       
                    setTimeout(() => {           
                        context.commit('add')  
                        //commit触发某个mutation       
                    }, 1000)       
                }         
            }   
        })   

    b.触发 Action 
        methods: { 
            handle() { 
                // 触发 actions 的第一种方式 
                this.$store.dispatch('addAsync') 
                //dispatch就是触发某个action
            } 
        }   

    c.触发 actions 异步任务时携带参数： 
        定义 Action   
        const store = new Vuex.Store({     
            // ...省略其他代码     
            mutations: { 
                addN(state, step) {         
                    state.count += step
                }   
            },     
        actions: {       
            addNAsync(context, step) {         
                setTimeout(() => {           
                    context.commit('addN', step)         
                    }, 1000)       
                }        
            }   
        })    
        触发 Action 
        methods: { 
            handle() { 
                // 在调用 dispatch 函数， 
                // 触发 actions 时携带参数 
                this.$store.dispatch('addNAsync', 5) 
            } 
        }  
```

#### 2.第二种方式

```
    this.$store.dispatch() 是触发 actions 的第一种方式，触发 actions 的第二种方式：  

    1.从 vuex 中按需导入 mapActions 函数 
        import { mapActions } from 'vuex'  

    通过刚才导入的 mapActions 函数，将需要的 actions 函数，映射为当前组件的 methods 方法： 
    2.将指定的 actions 函数，映射为当前组件的 methods 函数 
        methods: { 
            ...mapActions(['addASync', 'addNASync']) 
            //映射完成后相当于
            addASync(){...},
            addNASync(){...}
        }  
```

### 3.5 Getter 

```
  Getter 用于对 Store 中的数据进行加工处理形成新的数据,Getter不会改变store中的原数据，只起到一个包装器的作用。
    ① Getter 可以对 Store 中已有的数据加工处理之后形成新的数据，类似 Vue 的计算属性。 
    ② Store 中数据发生变化，Getter 的数据也会跟着变化。
```

####     1.定义 Getter 

```
    const store = new Vuex.Store({ 
        state: { 
            count: 0 
        }, 
        getters: { 
            showNum: state => { 
                return '当前最新的数量是【'+ state.count +'】' 
            } 
        } 
    })
```

####     2.使用 getters 的第一种方式： 

```
	this.$store.getters.名称 
```

####     3.使用 getters 的第二种方式： 

```
    import { mapGetters } from 'vuex' 
    
    computed: { 
    ...mapGetters(['showNum']) 
    } 
```

## 四、基于Vuex的案例
